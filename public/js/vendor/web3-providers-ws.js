/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendor/web3-providers-ws"],{

/***/ "./node_modules/web3-providers-ws/lib/helpers.js":
/*!*******************************************************!*\
  !*** ./node_modules/web3-providers-ws/lib/helpers.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\nvar isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';\nvar isRN = typeof navigator !== 'undefined' && navigator.product === 'ReactNative';\nvar _btoa = null;\nvar helpers = null;\nif (isNode || isRN) {\n    _btoa = function (str) {\n        return Buffer.from(str).toString('base64');\n    };\n    var url = __webpack_require__(/*! url */ \"./node_modules/url/url.js\");\n    if (url.URL) {\n        // Use the new Node 6+ API for parsing URLs that supports username/password\n        var newURL = url.URL;\n        helpers = function (url) {\n            return new newURL(url);\n        };\n    }\n    else {\n        // Web3 supports Node.js 5, so fall back to the legacy URL API if necessary\n        helpers = __webpack_require__(/*! url */ \"./node_modules/url/url.js\").parse;\n    }\n}\nelse {\n    _btoa = btoa.bind(window);\n    helpers = function (url) {\n        return new URL(url);\n    };\n}\nmodule.exports = {\n    parseURL: helpers,\n    btoa: _btoa\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlcnMtd3MvbGliL2hlbHBlcnMuanM/ZWZhYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLG1EQUFtRCxPQUFPLG1CQUFtQixPQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQSxjQUFjLG1CQUFPLENBQUMsc0NBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlFQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlcnMtd3MvbGliL2hlbHBlcnMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNOb2RlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyA/IHByb2Nlc3MgOiAwKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xudmFyIGlzUk4gPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJztcbnZhciBfYnRvYSA9IG51bGw7XG52YXIgaGVscGVycyA9IG51bGw7XG5pZiAoaXNOb2RlIHx8IGlzUk4pIHtcbiAgICBfYnRvYSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0cikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH07XG4gICAgdmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuICAgIGlmICh1cmwuVVJMKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgbmV3IE5vZGUgNisgQVBJIGZvciBwYXJzaW5nIFVSTHMgdGhhdCBzdXBwb3J0cyB1c2VybmFtZS9wYXNzd29yZFxuICAgICAgICB2YXIgbmV3VVJMID0gdXJsLlVSTDtcbiAgICAgICAgaGVscGVycyA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbmV3VVJMKHVybCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBXZWIzIHN1cHBvcnRzIE5vZGUuanMgNSwgc28gZmFsbCBiYWNrIHRvIHRoZSBsZWdhY3kgVVJMIEFQSSBpZiBuZWNlc3NhcnlcbiAgICAgICAgaGVscGVycyA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlO1xuICAgIH1cbn1cbmVsc2Uge1xuICAgIF9idG9hID0gYnRvYS5iaW5kKHdpbmRvdyk7XG4gICAgaGVscGVycyA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVUkwodXJsKTtcbiAgICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcGFyc2VVUkw6IGhlbHBlcnMsXG4gICAgYnRvYTogX2J0b2Fcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/web3-providers-ws/lib/helpers.js\n");

/***/ }),

/***/ "./node_modules/web3-providers-ws/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/web3-providers-ws/lib/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file WebsocketProvider.js\n * @authors: Samuel Furter <samuel@ethereum.org>, Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2019\n */\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\nvar helpers = __webpack_require__(/*! ./helpers.js */ \"./node_modules/web3-providers-ws/lib/helpers.js\");\nvar errors = __webpack_require__(/*! web3-core-helpers */ \"./node_modules/web3-core-helpers/lib/index.js\").errors;\nvar Ws = __webpack_require__(/*! websocket */ \"./node_modules/websocket/lib/browser.js\").w3cwebsocket;\n/**\n * @param {string} url\n * @param {Object} options\n *\n * @constructor\n */\nvar WebsocketProvider = function WebsocketProvider(url, options) {\n    EventEmitter.call(this);\n    options = options || {};\n    this.url = url;\n    this._customTimeout = options.timeout || 1000 * 15;\n    this.headers = options.headers || {};\n    this.protocol = options.protocol || undefined;\n    this.reconnectOptions = Object.assign({\n        auto: false,\n        delay: 5000,\n        maxAttempts: false,\n        onTimeout: false\n    }, options.reconnect);\n    this.clientConfig = options.clientConfig || undefined; // Allow a custom client configuration\n    this.requestOptions = options.requestOptions || undefined; // Allow a custom request options (https://github.com/theturtle32/WebSocket-Node/blob/master/docs/WebSocketClient.md#connectrequesturl-requestedprotocols-origin-headers-requestoptions)\n    this.DATA = 'data';\n    this.CLOSE = 'close';\n    this.ERROR = 'error';\n    this.CONNECT = 'connect';\n    this.RECONNECT = 'reconnect';\n    this.connection = null;\n    this.requestQueue = new Map();\n    this.responseQueue = new Map();\n    this.reconnectAttempts = 0;\n    this.reconnecting = false;\n    // The w3cwebsocket implementation does not support Basic Auth\n    // username/password in the URL. So generate the basic auth header, and\n    // pass through with any additional headers supplied in constructor\n    var parsedURL = helpers.parseURL(url);\n    if (parsedURL.username && parsedURL.password) {\n        this.headers.authorization = 'Basic ' + helpers.btoa(parsedURL.username + ':' + parsedURL.password);\n    }\n    // When all node core implementations that do not have the\n    // WHATWG compatible URL parser go out of service this line can be removed.\n    if (parsedURL.auth) {\n        this.headers.authorization = 'Basic ' + helpers.btoa(parsedURL.auth);\n    }\n    // make property `connected` which will return the current connection status\n    Object.defineProperty(this, 'connected', {\n        get: function () {\n            return this.connection && this.connection.readyState === this.connection.OPEN;\n        },\n        enumerable: true\n    });\n    this.connect();\n};\n// Inherit from EventEmitter\nWebsocketProvider.prototype = Object.create(EventEmitter.prototype);\nWebsocketProvider.prototype.constructor = WebsocketProvider;\n/**\n * Connects to the configured node\n *\n * @method connect\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.connect = function () {\n    this.connection = new Ws(this.url, this.protocol, undefined, this.headers, this.requestOptions, this.clientConfig);\n    this._addSocketListeners();\n};\n/**\n * Listener for the `data` event of the underlying WebSocket object\n *\n * @method _onMessage\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._onMessage = function (e) {\n    var _this = this;\n    this._parseResponse((typeof e.data === 'string') ? e.data : '').forEach(function (result) {\n        if (result.method && result.method.indexOf('_subscription') !== -1) {\n            _this.emit(_this.DATA, result);\n            return;\n        }\n        var id = result.id;\n        // get the id which matches the returned id\n        if (Array.isArray(result)) {\n            id = result[0].id;\n        }\n        if (_this.responseQueue.has(id)) {\n            if (_this.responseQueue.get(id).callback !== undefined) {\n                _this.responseQueue.get(id).callback(false, result);\n            }\n            _this.responseQueue.delete(id);\n        }\n    });\n};\n/**\n * Listener for the `open` event of the underlying WebSocket object\n *\n * @method _onConnect\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._onConnect = function () {\n    this.emit(this.CONNECT);\n    this.reconnectAttempts = 0;\n    this.reconnecting = false;\n    if (this.requestQueue.size > 0) {\n        var _this = this;\n        this.requestQueue.forEach(function (request, key) {\n            _this.send(request.payload, request.callback);\n            _this.requestQueue.delete(key);\n        });\n    }\n};\n/**\n * Listener for the `close` event of the underlying WebSocket object\n *\n * @method _onClose\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._onClose = function (event) {\n    var _this = this;\n    if (this.reconnectOptions.auto && (![1000, 1001].includes(event.code) || event.wasClean === false)) {\n        this.reconnect();\n        return;\n    }\n    this.emit(this.CLOSE, event);\n    if (this.requestQueue.size > 0) {\n        this.requestQueue.forEach(function (request, key) {\n            request.callback(errors.ConnectionNotOpenError(event));\n            _this.requestQueue.delete(key);\n        });\n    }\n    if (this.responseQueue.size > 0) {\n        this.responseQueue.forEach(function (request, key) {\n            request.callback(errors.InvalidConnection('on WS', event));\n            _this.responseQueue.delete(key);\n        });\n    }\n    this._removeSocketListeners();\n    this.removeAllListeners();\n};\n/**\n * Will add the required socket listeners\n *\n * @method _addSocketListeners\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._addSocketListeners = function () {\n    this.connection.addEventListener('message', this._onMessage.bind(this));\n    this.connection.addEventListener('open', this._onConnect.bind(this));\n    this.connection.addEventListener('close', this._onClose.bind(this));\n};\n/**\n * Will remove all socket listeners\n *\n * @method _removeSocketListeners\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._removeSocketListeners = function () {\n    this.connection.removeEventListener('message', this._onMessage);\n    this.connection.removeEventListener('open', this._onConnect);\n    this.connection.removeEventListener('close', this._onClose);\n};\n/**\n * Will parse the response and make an array out of it.\n *\n * @method _parseResponse\n *\n * @param {String} data\n *\n * @returns {Array}\n */\nWebsocketProvider.prototype._parseResponse = function (data) {\n    var _this = this, returnValues = [];\n    // DE-CHUNKER\n    var dechunkedData = data\n        .replace(/\\}[\\n\\r]?\\{/g, '}|--|{') // }{\n        .replace(/\\}\\][\\n\\r]?\\[\\{/g, '}]|--|[{') // }][{\n        .replace(/\\}[\\n\\r]?\\[\\{/g, '}|--|[{') // }[{\n        .replace(/\\}\\][\\n\\r]?\\{/g, '}]|--|{') // }]{\n        .split('|--|');\n    dechunkedData.forEach(function (data) {\n        // prepend the last chunk\n        if (_this.lastChunk)\n            data = _this.lastChunk + data;\n        var result = null;\n        try {\n            result = JSON.parse(data);\n        }\n        catch (e) {\n            _this.lastChunk = data;\n            // start timeout to cancel all requests\n            clearTimeout(_this.lastChunkTimeout);\n            _this.lastChunkTimeout = setTimeout(function () {\n                if (_this.reconnectOptions.auto && _this.reconnectOptions.onTimeout) {\n                    _this.reconnect();\n                    return;\n                }\n                _this.emit(_this.ERROR, errors.ConnectionTimeout(_this._customTimeout));\n                if (_this.requestQueue.size > 0) {\n                    _this.requestQueue.forEach(function (request, key) {\n                        request.callback(errors.ConnectionTimeout(_this._customTimeout));\n                        _this.requestQueue.delete(key);\n                    });\n                }\n            }, _this._customTimeout);\n            return;\n        }\n        // cancel timeout and set chunk to null\n        clearTimeout(_this.lastChunkTimeout);\n        _this.lastChunk = null;\n        if (result)\n            returnValues.push(result);\n    });\n    return returnValues;\n};\n/**\n * Does check if the provider is connecting and will add it to the queue or will send it directly\n *\n * @method send\n *\n * @param {Object} payload\n * @param {Function} callback\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.send = function (payload, callback) {\n    var _this = this;\n    var id = payload.id;\n    var request = { payload: payload, callback: callback };\n    if (Array.isArray(payload)) {\n        id = payload[0].id;\n    }\n    if (this.connection.readyState === this.connection.CONNECTING || this.reconnecting) {\n        this.requestQueue.set(id, request);\n        return;\n    }\n    if (this.connection.readyState !== this.connection.OPEN) {\n        this.requestQueue.delete(id);\n        this.emit(this.ERROR, errors.ConnectionNotOpenError());\n        request.callback(errors.ConnectionNotOpenError());\n        return;\n    }\n    this.responseQueue.set(id, request);\n    this.requestQueue.delete(id);\n    try {\n        this.connection.send(JSON.stringify(request.payload));\n    }\n    catch (error) {\n        request.callback(error);\n        _this.responseQueue.delete(id);\n    }\n};\n/**\n * Resets the providers, clears all callbacks\n *\n * @method reset\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.reset = function () {\n    this.responseQueue.clear();\n    this.requestQueue.clear();\n    this.removeAllListeners();\n    this._removeSocketListeners();\n    this._addSocketListeners();\n};\n/**\n * Closes the current connection with the given code and reason arguments\n *\n * @method disconnect\n *\n * @param {number} code\n * @param {string} reason\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.disconnect = function (code, reason) {\n    this._removeSocketListeners();\n    this.connection.close(code || 1000, reason);\n};\n/**\n * Returns the desired boolean.\n *\n * @method supportsSubscriptions\n *\n * @returns {boolean}\n */\nWebsocketProvider.prototype.supportsSubscriptions = function () {\n    return true;\n};\n/**\n * Removes the listeners and reconnects to the socket.\n *\n * @method reconnect\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.reconnect = function () {\n    var _this = this;\n    this.reconnecting = true;\n    if (this.responseQueue.size > 0) {\n        this.responseQueue.forEach(function (request, key) {\n            request.callback(errors.PendingRequestsOnReconnectingError());\n            _this.responseQueue.delete(key);\n        });\n    }\n    if (!this.reconnectOptions.maxAttempts ||\n        this.reconnectAttempts < this.reconnectOptions.maxAttempts) {\n        setTimeout(function () {\n            _this.reconnectAttempts++;\n            _this._removeSocketListeners();\n            _this.emit(_this.RECONNECT, _this.reconnectAttempts);\n            _this.connect();\n        }, this.reconnectOptions.delay);\n        return;\n    }\n    this.emit(this.ERROR, errors.MaxAttemptsReachedOnReconnectingError());\n    this.reconnecting = false;\n    if (this.requestQueue.size > 0) {\n        this.requestQueue.forEach(function (request, key) {\n            request.callback(errors.MaxAttemptsReachedOnReconnectingError());\n            _this.requestQueue.delete(key);\n        });\n    }\n};\nmodule.exports = WebsocketProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlcnMtd3MvbGliL2luZGV4LmpzP2E0Y2EiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLG1CQUFtQixtQkFBTyxDQUFDLDREQUFlO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyxxRUFBYztBQUNwQyxhQUFhLG9HQUFtQztBQUNoRCxTQUFTLDRGQUFpQztBQUMxQztBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBEQUEwRDtBQUMxRCw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVMsTUFBTSxLQUFLO0FBQ3hDLG9CQUFvQixhQUFhLE1BQU0sT0FBTyxPQUFPO0FBQ3JELG9CQUFvQixXQUFXLE1BQU0sTUFBTSxPQUFPO0FBQ2xELG9CQUFvQixXQUFXLE1BQU0sTUFBTSxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXJzLXdzL2xpYi9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiAqL1xuLyoqXG4gKiBAZmlsZSBXZWJzb2NrZXRQcm92aWRlci5qc1xuICogQGF1dGhvcnM6IFNhbXVlbCBGdXJ0ZXIgPHNhbXVlbEBldGhlcmV1bS5vcmc+LCBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogQGRhdGUgMjAxOVxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMycpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMuanMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCd3ZWIzLWNvcmUtaGVscGVycycpLmVycm9ycztcbnZhciBXcyA9IHJlcXVpcmUoJ3dlYnNvY2tldCcpLnczY3dlYnNvY2tldDtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFdlYnNvY2tldFByb3ZpZGVyID0gZnVuY3Rpb24gV2Vic29ja2V0UHJvdmlkZXIodXJsLCBvcHRpb25zKSB7XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5fY3VzdG9tVGltZW91dCA9IG9wdGlvbnMudGltZW91dCB8fCAxMDAwICogMTU7XG4gICAgdGhpcy5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuICAgIHRoaXMucHJvdG9jb2wgPSBvcHRpb25zLnByb3RvY29sIHx8IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJlY29ubmVjdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgYXV0bzogZmFsc2UsXG4gICAgICAgIGRlbGF5OiA1MDAwLFxuICAgICAgICBtYXhBdHRlbXB0czogZmFsc2UsXG4gICAgICAgIG9uVGltZW91dDogZmFsc2VcbiAgICB9LCBvcHRpb25zLnJlY29ubmVjdCk7XG4gICAgdGhpcy5jbGllbnRDb25maWcgPSBvcHRpb25zLmNsaWVudENvbmZpZyB8fCB1bmRlZmluZWQ7IC8vIEFsbG93IGEgY3VzdG9tIGNsaWVudCBjb25maWd1cmF0aW9uXG4gICAgdGhpcy5yZXF1ZXN0T3B0aW9ucyA9IG9wdGlvbnMucmVxdWVzdE9wdGlvbnMgfHwgdW5kZWZpbmVkOyAvLyBBbGxvdyBhIGN1c3RvbSByZXF1ZXN0IG9wdGlvbnMgKGh0dHBzOi8vZ2l0aHViLmNvbS90aGV0dXJ0bGUzMi9XZWJTb2NrZXQtTm9kZS9ibG9iL21hc3Rlci9kb2NzL1dlYlNvY2tldENsaWVudC5tZCNjb25uZWN0cmVxdWVzdHVybC1yZXF1ZXN0ZWRwcm90b2NvbHMtb3JpZ2luLWhlYWRlcnMtcmVxdWVzdG9wdGlvbnMpXG4gICAgdGhpcy5EQVRBID0gJ2RhdGEnO1xuICAgIHRoaXMuQ0xPU0UgPSAnY2xvc2UnO1xuICAgIHRoaXMuRVJST1IgPSAnZXJyb3InO1xuICAgIHRoaXMuQ09OTkVDVCA9ICdjb25uZWN0JztcbiAgICB0aGlzLlJFQ09OTkVDVCA9ICdyZWNvbm5lY3QnO1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgdGhpcy5yZXF1ZXN0UXVldWUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5yZXNwb25zZVF1ZXVlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICAgIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgLy8gVGhlIHczY3dlYnNvY2tldCBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCBzdXBwb3J0IEJhc2ljIEF1dGhcbiAgICAvLyB1c2VybmFtZS9wYXNzd29yZCBpbiB0aGUgVVJMLiBTbyBnZW5lcmF0ZSB0aGUgYmFzaWMgYXV0aCBoZWFkZXIsIGFuZFxuICAgIC8vIHBhc3MgdGhyb3VnaCB3aXRoIGFueSBhZGRpdGlvbmFsIGhlYWRlcnMgc3VwcGxpZWQgaW4gY29uc3RydWN0b3JcbiAgICB2YXIgcGFyc2VkVVJMID0gaGVscGVycy5wYXJzZVVSTCh1cmwpO1xuICAgIGlmIChwYXJzZWRVUkwudXNlcm5hbWUgJiYgcGFyc2VkVVJMLnBhc3N3b3JkKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5hdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBoZWxwZXJzLmJ0b2EocGFyc2VkVVJMLnVzZXJuYW1lICsgJzonICsgcGFyc2VkVVJMLnBhc3N3b3JkKTtcbiAgICB9XG4gICAgLy8gV2hlbiBhbGwgbm9kZSBjb3JlIGltcGxlbWVudGF0aW9ucyB0aGF0IGRvIG5vdCBoYXZlIHRoZVxuICAgIC8vIFdIQVRXRyBjb21wYXRpYmxlIFVSTCBwYXJzZXIgZ28gb3V0IG9mIHNlcnZpY2UgdGhpcyBsaW5lIGNhbiBiZSByZW1vdmVkLlxuICAgIGlmIChwYXJzZWRVUkwuYXV0aCkge1xuICAgICAgICB0aGlzLmhlYWRlcnMuYXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgaGVscGVycy5idG9hKHBhcnNlZFVSTC5hdXRoKTtcbiAgICB9XG4gICAgLy8gbWFrZSBwcm9wZXJ0eSBgY29ubmVjdGVkYCB3aGljaCB3aWxsIHJldHVybiB0aGUgY3VycmVudCBjb25uZWN0aW9uIHN0YXR1c1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29ubmVjdGVkJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24gJiYgdGhpcy5jb25uZWN0aW9uLnJlYWR5U3RhdGUgPT09IHRoaXMuY29ubmVjdGlvbi5PUEVOO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5jb25uZWN0KCk7XG59O1xuLy8gSW5oZXJpdCBmcm9tIEV2ZW50RW1pdHRlclxuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdlYnNvY2tldFByb3ZpZGVyO1xuLyoqXG4gKiBDb25uZWN0cyB0byB0aGUgY29uZmlndXJlZCBub2RlXG4gKlxuICogQG1ldGhvZCBjb25uZWN0XG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBXcyh0aGlzLnVybCwgdGhpcy5wcm90b2NvbCwgdW5kZWZpbmVkLCB0aGlzLmhlYWRlcnMsIHRoaXMucmVxdWVzdE9wdGlvbnMsIHRoaXMuY2xpZW50Q29uZmlnKTtcbiAgICB0aGlzLl9hZGRTb2NrZXRMaXN0ZW5lcnMoKTtcbn07XG4vKipcbiAqIExpc3RlbmVyIGZvciB0aGUgYGRhdGFgIGV2ZW50IG9mIHRoZSB1bmRlcmx5aW5nIFdlYlNvY2tldCBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIF9vbk1lc3NhZ2VcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLl9vbk1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5fcGFyc2VSZXNwb25zZSgodHlwZW9mIGUuZGF0YSA9PT0gJ3N0cmluZycpID8gZS5kYXRhIDogJycpLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0Lm1ldGhvZCAmJiByZXN1bHQubWV0aG9kLmluZGV4T2YoJ19zdWJzY3JpcHRpb24nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoX3RoaXMuREFUQSwgcmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWQgPSByZXN1bHQuaWQ7XG4gICAgICAgIC8vIGdldCB0aGUgaWQgd2hpY2ggbWF0Y2hlcyB0aGUgcmV0dXJuZWQgaWRcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgaWQgPSByZXN1bHRbMF0uaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzLnJlc3BvbnNlUXVldWUuaGFzKGlkKSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnJlc3BvbnNlUXVldWUuZ2V0KGlkKS5jYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVzcG9uc2VRdWV1ZS5nZXQoaWQpLmNhbGxiYWNrKGZhbHNlLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucmVzcG9uc2VRdWV1ZS5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuLyoqXG4gKiBMaXN0ZW5lciBmb3IgdGhlIGBvcGVuYCBldmVudCBvZiB0aGUgdW5kZXJseWluZyBXZWJTb2NrZXQgb2JqZWN0XG4gKlxuICogQG1ldGhvZCBfb25Db25uZWN0XG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5fb25Db25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW1pdCh0aGlzLkNPTk5FQ1QpO1xuICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICAgIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgaWYgKHRoaXMucmVxdWVzdFF1ZXVlLnNpemUgPiAwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVxdWVzdFF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3QsIGtleSkge1xuICAgICAgICAgICAgX3RoaXMuc2VuZChyZXF1ZXN0LnBheWxvYWQsIHJlcXVlc3QuY2FsbGJhY2spO1xuICAgICAgICAgICAgX3RoaXMucmVxdWVzdFF1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuLyoqXG4gKiBMaXN0ZW5lciBmb3IgdGhlIGBjbG9zZWAgZXZlbnQgb2YgdGhlIHVuZGVybHlpbmcgV2ViU29ja2V0IG9iamVjdFxuICpcbiAqIEBtZXRob2QgX29uQ2xvc2VcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLl9vbkNsb3NlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAodGhpcy5yZWNvbm5lY3RPcHRpb25zLmF1dG8gJiYgKCFbMTAwMCwgMTAwMV0uaW5jbHVkZXMoZXZlbnQuY29kZSkgfHwgZXZlbnQud2FzQ2xlYW4gPT09IGZhbHNlKSkge1xuICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW1pdCh0aGlzLkNMT1NFLCBldmVudCk7XG4gICAgaWYgKHRoaXMucmVxdWVzdFF1ZXVlLnNpemUgPiAwKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3QsIGtleSkge1xuICAgICAgICAgICAgcmVxdWVzdC5jYWxsYmFjayhlcnJvcnMuQ29ubmVjdGlvbk5vdE9wZW5FcnJvcihldmVudCkpO1xuICAgICAgICAgICAgX3RoaXMucmVxdWVzdFF1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVzcG9uc2VRdWV1ZS5zaXplID4gMCkge1xuICAgICAgICB0aGlzLnJlc3BvbnNlUXVldWUuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdCwga2V5KSB7XG4gICAgICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKGVycm9ycy5JbnZhbGlkQ29ubmVjdGlvbignb24gV1MnLCBldmVudCkpO1xuICAgICAgICAgICAgX3RoaXMucmVzcG9uc2VRdWV1ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlbW92ZVNvY2tldExpc3RlbmVycygpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuLyoqXG4gKiBXaWxsIGFkZCB0aGUgcmVxdWlyZWQgc29ja2V0IGxpc3RlbmVyc1xuICpcbiAqIEBtZXRob2QgX2FkZFNvY2tldExpc3RlbmVyc1xuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5XZWJzb2NrZXRQcm92aWRlci5wcm90b3R5cGUuX2FkZFNvY2tldExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX29uTWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIHRoaXMuX29uQ29ubmVjdC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCB0aGlzLl9vbkNsb3NlLmJpbmQodGhpcykpO1xufTtcbi8qKlxuICogV2lsbCByZW1vdmUgYWxsIHNvY2tldCBsaXN0ZW5lcnNcbiAqXG4gKiBAbWV0aG9kIF9yZW1vdmVTb2NrZXRMaXN0ZW5lcnNcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLl9yZW1vdmVTb2NrZXRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9vbk1lc3NhZ2UpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdvcGVuJywgdGhpcy5fb25Db25uZWN0KTtcbiAgICB0aGlzLmNvbm5lY3Rpb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xvc2UnLCB0aGlzLl9vbkNsb3NlKTtcbn07XG4vKipcbiAqIFdpbGwgcGFyc2UgdGhlIHJlc3BvbnNlIGFuZCBtYWtlIGFuIGFycmF5IG91dCBvZiBpdC5cbiAqXG4gKiBAbWV0aG9kIF9wYXJzZVJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5fcGFyc2VSZXNwb25zZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcywgcmV0dXJuVmFsdWVzID0gW107XG4gICAgLy8gREUtQ0hVTktFUlxuICAgIHZhciBkZWNodW5rZWREYXRhID0gZGF0YVxuICAgICAgICAucmVwbGFjZSgvXFx9W1xcblxccl0/XFx7L2csICd9fC0tfHsnKSAvLyB9e1xuICAgICAgICAucmVwbGFjZSgvXFx9XFxdW1xcblxccl0/XFxbXFx7L2csICd9XXwtLXxbeycpIC8vIH1dW3tcbiAgICAgICAgLnJlcGxhY2UoL1xcfVtcXG5cXHJdP1xcW1xcey9nLCAnfXwtLXxbeycpIC8vIH1be1xuICAgICAgICAucmVwbGFjZSgvXFx9XFxdW1xcblxccl0/XFx7L2csICd9XXwtLXx7JykgLy8gfV17XG4gICAgICAgIC5zcGxpdCgnfC0tfCcpO1xuICAgIGRlY2h1bmtlZERhdGEuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAvLyBwcmVwZW5kIHRoZSBsYXN0IGNodW5rXG4gICAgICAgIGlmIChfdGhpcy5sYXN0Q2h1bmspXG4gICAgICAgICAgICBkYXRhID0gX3RoaXMubGFzdENodW5rICsgZGF0YTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBfdGhpcy5sYXN0Q2h1bmsgPSBkYXRhO1xuICAgICAgICAgICAgLy8gc3RhcnQgdGltZW91dCB0byBjYW5jZWwgYWxsIHJlcXVlc3RzXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMubGFzdENodW5rVGltZW91dCk7XG4gICAgICAgICAgICBfdGhpcy5sYXN0Q2h1bmtUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlY29ubmVjdE9wdGlvbnMuYXV0byAmJiBfdGhpcy5yZWNvbm5lY3RPcHRpb25zLm9uVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KF90aGlzLkVSUk9SLCBlcnJvcnMuQ29ubmVjdGlvblRpbWVvdXQoX3RoaXMuX2N1c3RvbVRpbWVvdXQpKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVxdWVzdFF1ZXVlLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlcXVlc3RRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXN0LCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyb3JzLkNvbm5lY3Rpb25UaW1lb3V0KF90aGlzLl9jdXN0b21UaW1lb3V0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXF1ZXN0UXVldWUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF90aGlzLl9jdXN0b21UaW1lb3V0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYW5jZWwgdGltZW91dCBhbmQgc2V0IGNodW5rIHRvIG51bGxcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmxhc3RDaHVua1RpbWVvdXQpO1xuICAgICAgICBfdGhpcy5sYXN0Q2h1bmsgPSBudWxsO1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuVmFsdWVzLnB1c2gocmVzdWx0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xufTtcbi8qKlxuICogRG9lcyBjaGVjayBpZiB0aGUgcHJvdmlkZXIgaXMgY29ubmVjdGluZyBhbmQgd2lsbCBhZGQgaXQgdG8gdGhlIHF1ZXVlIG9yIHdpbGwgc2VuZCBpdCBkaXJlY3RseVxuICpcbiAqIEBtZXRob2Qgc2VuZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5XZWJzb2NrZXRQcm92aWRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGlkID0gcGF5bG9hZC5pZDtcbiAgICB2YXIgcmVxdWVzdCA9IHsgcGF5bG9hZDogcGF5bG9hZCwgY2FsbGJhY2s6IGNhbGxiYWNrIH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkpIHtcbiAgICAgICAgaWQgPSBwYXlsb2FkWzBdLmlkO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25uZWN0aW9uLnJlYWR5U3RhdGUgPT09IHRoaXMuY29ubmVjdGlvbi5DT05ORUNUSU5HIHx8IHRoaXMucmVjb25uZWN0aW5nKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFF1ZXVlLnNldChpZCwgcmVxdWVzdCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbi5yZWFkeVN0YXRlICE9PSB0aGlzLmNvbm5lY3Rpb24uT1BFTikge1xuICAgICAgICB0aGlzLnJlcXVlc3RRdWV1ZS5kZWxldGUoaWQpO1xuICAgICAgICB0aGlzLmVtaXQodGhpcy5FUlJPUiwgZXJyb3JzLkNvbm5lY3Rpb25Ob3RPcGVuRXJyb3IoKSk7XG4gICAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyb3JzLkNvbm5lY3Rpb25Ob3RPcGVuRXJyb3IoKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZXNwb25zZVF1ZXVlLnNldChpZCwgcmVxdWVzdCk7XG4gICAgdGhpcy5yZXF1ZXN0UXVldWUuZGVsZXRlKGlkKTtcbiAgICB0cnkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uc2VuZChKU09OLnN0cmluZ2lmeShyZXF1ZXN0LnBheWxvYWQpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICBfdGhpcy5yZXNwb25zZVF1ZXVlLmRlbGV0ZShpZCk7XG4gICAgfVxufTtcbi8qKlxuICogUmVzZXRzIHRoZSBwcm92aWRlcnMsIGNsZWFycyBhbGwgY2FsbGJhY2tzXG4gKlxuICogQG1ldGhvZCByZXNldFxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5XZWJzb2NrZXRQcm92aWRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZXNwb25zZVF1ZXVlLmNsZWFyKCk7XG4gICAgdGhpcy5yZXF1ZXN0UXVldWUuY2xlYXIoKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuX3JlbW92ZVNvY2tldExpc3RlbmVycygpO1xuICAgIHRoaXMuX2FkZFNvY2tldExpc3RlbmVycygpO1xufTtcbi8qKlxuICogQ2xvc2VzIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gY29kZSBhbmQgcmVhc29uIGFyZ3VtZW50c1xuICpcbiAqIEBtZXRob2QgZGlzY29ubmVjdFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKGNvZGUsIHJlYXNvbikge1xuICAgIHRoaXMuX3JlbW92ZVNvY2tldExpc3RlbmVycygpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5jbG9zZShjb2RlIHx8IDEwMDAsIHJlYXNvbik7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZXNpcmVkIGJvb2xlYW4uXG4gKlxuICogQG1ldGhvZCBzdXBwb3J0c1N1YnNjcmlwdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLnN1cHBvcnRzU3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIFJlbW92ZXMgdGhlIGxpc3RlbmVycyBhbmQgcmVjb25uZWN0cyB0byB0aGUgc29ja2V0LlxuICpcbiAqIEBtZXRob2QgcmVjb25uZWN0XG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG4gICAgaWYgKHRoaXMucmVzcG9uc2VRdWV1ZS5zaXplID4gMCkge1xuICAgICAgICB0aGlzLnJlc3BvbnNlUXVldWUuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdCwga2V5KSB7XG4gICAgICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKGVycm9ycy5QZW5kaW5nUmVxdWVzdHNPblJlY29ubmVjdGluZ0Vycm9yKCkpO1xuICAgICAgICAgICAgX3RoaXMucmVzcG9uc2VRdWV1ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5yZWNvbm5lY3RPcHRpb25zLm1heEF0dGVtcHRzIHx8XG4gICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPCB0aGlzLnJlY29ubmVjdE9wdGlvbnMubWF4QXR0ZW1wdHMpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5yZWNvbm5lY3RBdHRlbXB0cysrO1xuICAgICAgICAgICAgX3RoaXMuX3JlbW92ZVNvY2tldExpc3RlbmVycygpO1xuICAgICAgICAgICAgX3RoaXMuZW1pdChfdGhpcy5SRUNPTk5FQ1QsIF90aGlzLnJlY29ubmVjdEF0dGVtcHRzKTtcbiAgICAgICAgICAgIF90aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgfSwgdGhpcy5yZWNvbm5lY3RPcHRpb25zLmRlbGF5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQodGhpcy5FUlJPUiwgZXJyb3JzLk1heEF0dGVtcHRzUmVhY2hlZE9uUmVjb25uZWN0aW5nRXJyb3IoKSk7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5yZXF1ZXN0UXVldWUuc2l6ZSA+IDApIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UXVldWUuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdCwga2V5KSB7XG4gICAgICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKGVycm9ycy5NYXhBdHRlbXB0c1JlYWNoZWRPblJlY29ubmVjdGluZ0Vycm9yKCkpO1xuICAgICAgICAgICAgX3RoaXMucmVxdWVzdFF1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBXZWJzb2NrZXRQcm92aWRlcjtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/web3-providers-ws/lib/index.js\n");

/***/ })

}]);