/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendor/web3-eth-contract"],{

/***/ "./node_modules/web3-eth-contract/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/web3-eth-contract/lib/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file contract.js\n *\n * To initialize a contract use:\n *\n *  var Contract = require('web3-eth-contract');\n *  Contract.setProvider('ws://localhost:8546');\n *  var contract = new Contract(abi, address, ...);\n *\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nvar _ = __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore.js\");\nvar core = __webpack_require__(/*! web3-core */ \"./node_modules/web3-core/lib/index.js\");\nvar Method = __webpack_require__(/*! web3-core-method */ \"./node_modules/web3-core-method/lib/index.js\");\nvar utils = __webpack_require__(/*! web3-utils */ \"./node_modules/web3-utils/lib/index.js\");\nvar Subscription = __webpack_require__(/*! web3-core-subscriptions */ \"./node_modules/web3-core-subscriptions/lib/index.js\").subscription;\nvar formatters = __webpack_require__(/*! web3-core-helpers */ \"./node_modules/web3-core-helpers/lib/index.js\").formatters;\nvar errors = __webpack_require__(/*! web3-core-helpers */ \"./node_modules/web3-core-helpers/lib/index.js\").errors;\nvar promiEvent = __webpack_require__(/*! web3-core-promievent */ \"./node_modules/web3-core-promievent/lib/index.js\");\nvar abi = __webpack_require__(/*! web3-eth-abi */ \"./node_modules/web3-eth-abi/lib/index.js\");\n/**\n * Should be called to create new contract instance\n *\n * @method Contract\n * @constructor\n * @param {Array} jsonInterface\n * @param {String} address\n * @param {Object} options\n */\nvar Contract = function Contract(jsonInterface, address, options) {\n    var _this = this, args = Array.prototype.slice.call(arguments);\n    if (!(this instanceof Contract)) {\n        throw new Error('Please use the \"new\" keyword to instantiate a web3.eth.Contract() object!');\n    }\n    this.setProvider = function () {\n        core.packageInit(_this, arguments);\n        _this.clearSubscriptions = _this._requestManager.clearSubscriptions;\n    };\n    // sets _requestmanager\n    core.packageInit(this, [this.constructor]);\n    this.clearSubscriptions = this._requestManager.clearSubscriptions;\n    if (!jsonInterface || !(Array.isArray(jsonInterface))) {\n        throw errors.ContractMissingABIError();\n    }\n    // create the options object\n    this.options = {};\n    var lastArg = args[args.length - 1];\n    if (_.isObject(lastArg) && !_.isArray(lastArg)) {\n        options = lastArg;\n        this.options = _.extend(this.options, this._getOrSetDefaultOptions(options));\n        if (_.isObject(address)) {\n            address = null;\n        }\n    }\n    // set address\n    Object.defineProperty(this.options, 'address', {\n        set: function (value) {\n            if (value) {\n                _this._address = utils.toChecksumAddress(formatters.inputAddressFormatter(value));\n            }\n        },\n        get: function () {\n            return _this._address;\n        },\n        enumerable: true\n    });\n    // add method and event signatures, when the jsonInterface gets set\n    Object.defineProperty(this.options, 'jsonInterface', {\n        set: function (value) {\n            _this.methods = {};\n            _this.events = {};\n            _this._jsonInterface = value.map(function (method) {\n                var func, funcName;\n                // make constant and payable backwards compatible\n                method.constant = (method.stateMutability === \"view\" || method.stateMutability === \"pure\" || method.constant);\n                method.payable = (method.stateMutability === \"payable\" || method.payable);\n                if (method.name) {\n                    funcName = utils._jsonInterfaceMethodToString(method);\n                }\n                // function\n                if (method.type === 'function') {\n                    method.signature = abi.encodeFunctionSignature(funcName);\n                    func = _this._createTxObject.bind({\n                        method: method,\n                        parent: _this\n                    });\n                    // add method only if not one already exists\n                    if (!_this.methods[method.name]) {\n                        _this.methods[method.name] = func;\n                    }\n                    else {\n                        var cascadeFunc = _this._createTxObject.bind({\n                            method: method,\n                            parent: _this,\n                            nextMethod: _this.methods[method.name]\n                        });\n                        _this.methods[method.name] = cascadeFunc;\n                    }\n                    // definitely add the method based on its signature\n                    _this.methods[method.signature] = func;\n                    // add method by name\n                    _this.methods[funcName] = func;\n                    // event\n                }\n                else if (method.type === 'event') {\n                    method.signature = abi.encodeEventSignature(funcName);\n                    var event = _this._on.bind(_this, method.signature);\n                    // add method only if not already exists\n                    if (!_this.events[method.name] || _this.events[method.name].name === 'bound ')\n                        _this.events[method.name] = event;\n                    // definitely add the method based on its signature\n                    _this.events[method.signature] = event;\n                    // add event by name\n                    _this.events[funcName] = event;\n                }\n                return method;\n            });\n            // add allEvents\n            _this.events.allEvents = _this._on.bind(_this, 'allevents');\n            return _this._jsonInterface;\n        },\n        get: function () {\n            return _this._jsonInterface;\n        },\n        enumerable: true\n    });\n    // get default account from the Class\n    var defaultAccount = this.constructor.defaultAccount;\n    var defaultBlock = this.constructor.defaultBlock || 'latest';\n    Object.defineProperty(this, 'handleRevert', {\n        get: function () {\n            if (_this.options.handleRevert === false || _this.options.handleRevert === true) {\n                return _this.options.handleRevert;\n            }\n            return this.constructor.handleRevert;\n        },\n        set: function (val) {\n            _this.options.handleRevert = val;\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'defaultCommon', {\n        get: function () {\n            return _this.options.common || this.constructor.defaultCommon;\n        },\n        set: function (val) {\n            _this.options.common = val;\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'defaultHardfork', {\n        get: function () {\n            return _this.options.hardfork || this.constructor.defaultHardfork;\n        },\n        set: function (val) {\n            _this.options.hardfork = val;\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'defaultChain', {\n        get: function () {\n            return _this.options.chain || this.constructor.defaultChain;\n        },\n        set: function (val) {\n            _this.options.chain = val;\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'transactionPollingTimeout', {\n        get: function () {\n            if (_this.options.transactionPollingTimeout === 0) {\n                return _this.options.transactionPollingTimeout;\n            }\n            return _this.options.transactionPollingTimeout || this.constructor.transactionPollingTimeout;\n        },\n        set: function (val) {\n            _this.options.transactionPollingTimeout = val;\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'transactionConfirmationBlocks', {\n        get: function () {\n            if (_this.options.transactionConfirmationBlocks === 0) {\n                return _this.options.transactionConfirmationBlocks;\n            }\n            return _this.options.transactionConfirmationBlocks || this.constructor.transactionConfirmationBlocks;\n        },\n        set: function (val) {\n            _this.options.transactionConfirmationBlocks = val;\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'transactionBlockTimeout', {\n        get: function () {\n            if (_this.options.transactionBlockTimeout === 0) {\n                return _this.options.transactionBlockTimeout;\n            }\n            return _this.options.transactionBlockTimeout || this.constructor.transactionBlockTimeout;\n        },\n        set: function (val) {\n            _this.options.transactionBlockTimeout = val;\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'defaultAccount', {\n        get: function () {\n            return defaultAccount;\n        },\n        set: function (val) {\n            if (val) {\n                defaultAccount = utils.toChecksumAddress(formatters.inputAddressFormatter(val));\n            }\n            return val;\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'defaultBlock', {\n        get: function () {\n            return defaultBlock;\n        },\n        set: function (val) {\n            defaultBlock = val;\n            return val;\n        },\n        enumerable: true\n    });\n    // properties\n    this.methods = {};\n    this.events = {};\n    this._address = null;\n    this._jsonInterface = [];\n    // set getter/setter properties\n    this.options.address = address;\n    this.options.jsonInterface = jsonInterface;\n};\n/**\n * Sets the new provider, creates a new requestManager, registers the \"data\" listener on the provider and sets the\n * accounts module for the Contract class.\n *\n * @method setProvider\n *\n * @param {string|provider} provider\n * @param {Accounts} accounts\n *\n * @returns void\n */\nContract.setProvider = function (provider, accounts) {\n    // Contract.currentProvider = provider;\n    core.packageInit(this, [provider]);\n    this._ethAccounts = accounts;\n};\n/**\n * Get the callback and modify the array if necessary\n *\n * @method _getCallback\n * @param {Array} args\n * @return {Function} the callback\n */\nContract.prototype._getCallback = function getCallback(args) {\n    if (args && _.isFunction(args[args.length - 1])) {\n        return args.pop(); // modify the args array!\n    }\n};\n/**\n * Checks that no listener with name \"newListener\" or \"removeListener\" is added.\n *\n * @method _checkListener\n * @param {String} type\n * @param {String} event\n * @return {Object} the contract instance\n */\nContract.prototype._checkListener = function (type, event) {\n    if (event === type) {\n        throw errors.ContractReservedEventError(type);\n    }\n};\n/**\n * Use default values, if options are not available\n *\n * @method _getOrSetDefaultOptions\n * @param {Object} options the options gived by the user\n * @return {Object} the options with gaps filled by defaults\n */\nContract.prototype._getOrSetDefaultOptions = function getOrSetDefaultOptions(options) {\n    var gasPrice = options.gasPrice ? String(options.gasPrice) : null;\n    var from = options.from ? utils.toChecksumAddress(formatters.inputAddressFormatter(options.from)) : null;\n    options.data = options.data || this.options.data;\n    options.from = from || this.options.from;\n    options.gasPrice = gasPrice || this.options.gasPrice;\n    options.gas = options.gas || options.gasLimit || this.options.gas;\n    // TODO replace with only gasLimit?\n    delete options.gasLimit;\n    return options;\n};\n/**\n * Should be used to encode indexed params and options to one final object\n *\n * @method _encodeEventABI\n * @param {Object} event\n * @param {Object} options\n * @return {Object} everything combined together and encoded\n */\nContract.prototype._encodeEventABI = function (event, options) {\n    options = options || {};\n    var filter = options.filter || {}, result = {};\n    ['fromBlock', 'toBlock'].filter(function (f) {\n        return options[f] !== undefined;\n    }).forEach(function (f) {\n        result[f] = formatters.inputBlockNumberFormatter(options[f]);\n    });\n    // use given topics\n    if (_.isArray(options.topics)) {\n        result.topics = options.topics;\n        // create topics based on filter\n    }\n    else {\n        result.topics = [];\n        // add event signature\n        if (event && !event.anonymous && event.name !== 'ALLEVENTS') {\n            result.topics.push(event.signature);\n        }\n        // add event topics (indexed arguments)\n        if (event.name !== 'ALLEVENTS') {\n            var indexedTopics = event.inputs.filter(function (i) {\n                return i.indexed === true;\n            }).map(function (i) {\n                var value = filter[i.name];\n                if (!value) {\n                    return null;\n                }\n                // TODO: https://github.com/ethereum/web3.js/issues/344\n                // TODO: deal properly with components\n                if (_.isArray(value)) {\n                    return value.map(function (v) {\n                        return abi.encodeParameter(i.type, v);\n                    });\n                }\n                return abi.encodeParameter(i.type, value);\n            });\n            result.topics = result.topics.concat(indexedTopics);\n        }\n        if (!result.topics.length)\n            delete result.topics;\n    }\n    if (this.options.address) {\n        result.address = this.options.address.toLowerCase();\n    }\n    return result;\n};\n/**\n * Should be used to decode indexed params and options\n *\n * @method _decodeEventABI\n * @param {Object} data\n * @return {Object} result object with decoded indexed && not indexed params\n */\nContract.prototype._decodeEventABI = function (data) {\n    var event = this;\n    data.data = data.data || '';\n    data.topics = data.topics || [];\n    var result = formatters.outputLogFormatter(data);\n    // if allEvents get the right event\n    if (event.name === 'ALLEVENTS') {\n        event = event.jsonInterface.find(function (intf) {\n            return (intf.signature === data.topics[0]);\n        }) || { anonymous: true };\n    }\n    // create empty inputs if none are present (e.g. anonymous events on allEvents)\n    event.inputs = event.inputs || [];\n    // Handle case where an event signature shadows the current ABI with non-identical\n    // arg indexing. If # of topics doesn't match, event is anon.\n    if (!event.anonymous) {\n        let indexedInputs = 0;\n        event.inputs.forEach(input => input.indexed ? indexedInputs++ : null);\n        if (indexedInputs > 0 && (data.topics.length !== indexedInputs + 1)) {\n            event = {\n                anonymous: true,\n                inputs: []\n            };\n        }\n    }\n    var argTopics = event.anonymous ? data.topics : data.topics.slice(1);\n    result.returnValues = abi.decodeLog(event.inputs, data.data, argTopics);\n    delete result.returnValues.__length__;\n    // add name\n    result.event = event.name;\n    // add signature\n    result.signature = (event.anonymous || !data.topics[0]) ? null : data.topics[0];\n    // move the data and topics to \"raw\"\n    result.raw = {\n        data: result.data,\n        topics: result.topics\n    };\n    delete result.data;\n    delete result.topics;\n    return result;\n};\n/**\n * Encodes an ABI for a method, including signature or the method.\n * Or when constructor encodes only the constructor parameters.\n *\n * @method _encodeMethodABI\n * @param {Mixed} args the arguments to encode\n * @param {String} the encoded ABI\n */\nContract.prototype._encodeMethodABI = function _encodeMethodABI() {\n    var methodSignature = this._method.signature, args = this.arguments || [];\n    var signature = false, paramsABI = this._parent.options.jsonInterface.filter(function (json) {\n        return ((methodSignature === 'constructor' && json.type === methodSignature) ||\n            ((json.signature === methodSignature || json.signature === methodSignature.replace('0x', '') || json.name === methodSignature) && json.type === 'function'));\n    }).map(function (json) {\n        var inputLength = (_.isArray(json.inputs)) ? json.inputs.length : 0;\n        if (inputLength !== args.length) {\n            throw new Error('The number of arguments is not matching the methods required number. You need to pass ' + inputLength + ' arguments.');\n        }\n        if (json.type === 'function') {\n            signature = json.signature;\n        }\n        return _.isArray(json.inputs) ? json.inputs : [];\n    }).map(function (inputs) {\n        return abi.encodeParameters(inputs, args).replace('0x', '');\n    })[0] || '';\n    // return constructor\n    if (methodSignature === 'constructor') {\n        if (!this._deployData)\n            throw new Error('The contract has no contract data option set. This is necessary to append the constructor parameters.');\n        if (!this._deployData.startsWith('0x')) {\n            this._deployData = '0x' + this._deployData;\n        }\n        return this._deployData + paramsABI;\n    }\n    // return method\n    var returnValue = (signature) ? signature + paramsABI : paramsABI;\n    if (!returnValue) {\n        throw new Error('Couldn\\'t find a matching contract method named \"' + this._method.name + '\".');\n    }\n    return returnValue;\n};\n/**\n * Decode method return values\n *\n * @method _decodeMethodReturn\n * @param {Array} outputs\n * @param {String} returnValues\n * @return {Object} decoded output return values\n */\nContract.prototype._decodeMethodReturn = function (outputs, returnValues) {\n    if (!returnValues) {\n        return null;\n    }\n    returnValues = returnValues.length >= 2 ? returnValues.slice(2) : returnValues;\n    var result = abi.decodeParameters(outputs, returnValues);\n    if (result.__length__ === 1) {\n        return result[0];\n    }\n    delete result.__length__;\n    return result;\n};\n/**\n * Deploys a contract and fire events based on its state: transactionHash, receipt\n *\n * All event listeners will be removed, once the last possible event is fired (\"error\", or \"receipt\")\n *\n * @method deploy\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} EventEmitter possible events are \"error\", \"transactionHash\" and \"receipt\"\n */\nContract.prototype.deploy = function (options, callback) {\n    options = options || {};\n    options.arguments = options.arguments || [];\n    options = this._getOrSetDefaultOptions(options);\n    // throw error, if no \"data\" is specified\n    if (!options.data) {\n        if (typeof callback === 'function') {\n            return callback(errors.ContractMissingDeployDataError());\n        }\n        throw errors.ContractMissingDeployDataError();\n    }\n    var constructor = _.find(this.options.jsonInterface, function (method) {\n        return (method.type === 'constructor');\n    }) || {};\n    constructor.signature = 'constructor';\n    return this._createTxObject.apply({\n        method: constructor,\n        parent: this,\n        deployData: options.data,\n        _ethAccounts: this.constructor._ethAccounts\n    }, options.arguments);\n};\n/**\n * Gets the event signature and outputFormatters\n *\n * @method _generateEventOptions\n * @param {Object} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the event options object\n */\nContract.prototype._generateEventOptions = function () {\n    var args = Array.prototype.slice.call(arguments);\n    // get the callback\n    var callback = this._getCallback(args);\n    // get the options\n    var options = (_.isObject(args[args.length - 1])) ? args.pop() : {};\n    var eventName = (_.isString(args[0])) ? args[0] : 'allevents';\n    var event = (eventName.toLowerCase() === 'allevents') ? {\n        name: 'ALLEVENTS',\n        jsonInterface: this.options.jsonInterface\n    } : this.options.jsonInterface.find(function (json) {\n        return (json.type === 'event' && (json.name === eventName || json.signature === '0x' + eventName.replace('0x', '')));\n    });\n    if (!event) {\n        throw errors.ContractEventDoesNotExistError(eventName);\n    }\n    if (!utils.isAddress(this.options.address)) {\n        throw errors.ContractNoAddressDefinedError();\n    }\n    return {\n        params: this._encodeEventABI(event, options),\n        event: event,\n        callback: callback\n    };\n};\n/**\n * Adds event listeners and creates a subscription, and remove it once its fired.\n *\n * @method clone\n * @return {Object} the event subscription\n */\nContract.prototype.clone = function () {\n    return new this.constructor(this.options.jsonInterface, this.options.address, this.options);\n};\n/**\n * Adds event listeners and creates a subscription, and remove it once its fired.\n *\n * @method once\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the event subscription\n */\nContract.prototype.once = function (event, options, callback) {\n    var args = Array.prototype.slice.call(arguments);\n    // get the callback\n    callback = this._getCallback(args);\n    if (!callback) {\n        throw errors.ContractOnceRequiresCallbackError();\n    }\n    // don't allow fromBlock\n    if (options)\n        delete options.fromBlock;\n    // don't return as once shouldn't provide \"on\"\n    this._on(event, options, function (err, res, sub) {\n        sub.unsubscribe();\n        if (_.isFunction(callback)) {\n            callback(err, res, sub);\n        }\n    });\n    return undefined;\n};\n/**\n * Adds event listeners and creates a subscription.\n *\n * @method _on\n *\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n *\n * @return {Object} the event subscription\n */\nContract.prototype._on = function () {\n    var subOptions = this._generateEventOptions.apply(this, arguments);\n    if (subOptions.params && subOptions.params.toBlock) {\n        delete subOptions.params.toBlock;\n        console.warn('Invalid option: toBlock. Use getPastEvents for specific range.');\n    }\n    // prevent the event \"newListener\" and \"removeListener\" from being overwritten\n    this._checkListener('newListener', subOptions.event.name);\n    this._checkListener('removeListener', subOptions.event.name);\n    // TODO check if listener already exists? and reuse subscription if options are the same.\n    // create new subscription\n    var subscription = new Subscription({\n        subscription: {\n            params: 1,\n            inputFormatter: [formatters.inputLogFormatter],\n            outputFormatter: this._decodeEventABI.bind(subOptions.event),\n            // DUBLICATE, also in web3-eth\n            subscriptionHandler: function (output) {\n                if (output.removed) {\n                    this.emit('changed', output);\n                }\n                else {\n                    this.emit('data', output);\n                }\n                if (_.isFunction(this.callback)) {\n                    this.callback(null, output, this);\n                }\n            }\n        },\n        type: 'eth',\n        requestManager: this._requestManager\n    });\n    subscription.subscribe('logs', subOptions.params, subOptions.callback || function () { });\n    return subscription;\n};\n/**\n * Get past events from contracts\n *\n * @method getPastEvents\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the promievent\n */\nContract.prototype.getPastEvents = function () {\n    var subOptions = this._generateEventOptions.apply(this, arguments);\n    var getPastLogs = new Method({\n        name: 'getPastLogs',\n        call: 'eth_getLogs',\n        params: 1,\n        inputFormatter: [formatters.inputLogFormatter],\n        outputFormatter: this._decodeEventABI.bind(subOptions.event)\n    });\n    getPastLogs.setRequestManager(this._requestManager);\n    var call = getPastLogs.buildCall();\n    getPastLogs = null;\n    return call(subOptions.params, subOptions.callback);\n};\n/**\n * returns the an object with call, send, estimate functions\n *\n * @method _createTxObject\n * @returns {Object} an object with functions to call the methods\n */\nContract.prototype._createTxObject = function _createTxObject() {\n    var args = Array.prototype.slice.call(arguments);\n    var txObject = {};\n    if (this.method.type === 'function') {\n        txObject.call = this.parent._executeMethod.bind(txObject, 'call');\n        txObject.call.request = this.parent._executeMethod.bind(txObject, 'call', true); // to make batch requests\n    }\n    txObject.send = this.parent._executeMethod.bind(txObject, 'send');\n    txObject.send.request = this.parent._executeMethod.bind(txObject, 'send', true); // to make batch requests\n    txObject.encodeABI = this.parent._encodeMethodABI.bind(txObject);\n    txObject.estimateGas = this.parent._executeMethod.bind(txObject, 'estimate');\n    if (args && this.method.inputs && args.length !== this.method.inputs.length) {\n        if (this.nextMethod) {\n            return this.nextMethod.apply(null, args);\n        }\n        throw errors.InvalidNumberOfParams(args.length, this.method.inputs.length, this.method.name);\n    }\n    txObject.arguments = args || [];\n    txObject._method = this.method;\n    txObject._parent = this.parent;\n    txObject._ethAccounts = this.parent.constructor._ethAccounts || this._ethAccounts;\n    if (this.deployData) {\n        txObject._deployData = this.deployData;\n    }\n    return txObject;\n};\n/**\n * Generates the options for the execute call\n *\n * @method _processExecuteArguments\n * @param {Array} args\n * @param {Promise} defer\n */\nContract.prototype._processExecuteArguments = function _processExecuteArguments(args, defer) {\n    var processedArgs = {};\n    processedArgs.type = args.shift();\n    // get the callback\n    processedArgs.callback = this._parent._getCallback(args);\n    // get block number to use for call\n    if (processedArgs.type === 'call' && args[args.length - 1] !== true && (_.isString(args[args.length - 1]) || isFinite(args[args.length - 1])))\n        processedArgs.defaultBlock = args.pop();\n    // get the options\n    processedArgs.options = (_.isObject(args[args.length - 1])) ? args.pop() : {};\n    // get the generateRequest argument for batch requests\n    processedArgs.generateRequest = (args[args.length - 1] === true) ? args.pop() : false;\n    processedArgs.options = this._parent._getOrSetDefaultOptions(processedArgs.options);\n    processedArgs.options.data = this.encodeABI();\n    // add contract address\n    if (!this._deployData && !utils.isAddress(this._parent.options.address))\n        throw errors.ContractNoAddressDefinedError();\n    if (!this._deployData)\n        processedArgs.options.to = this._parent.options.address;\n    // return error, if no \"data\" is specified\n    if (!processedArgs.options.data)\n        return utils._fireError(new Error('Couldn\\'t find a matching contract method, or the number of parameters is wrong.'), defer.eventEmitter, defer.reject, processedArgs.callback);\n    return processedArgs;\n};\n/**\n * Executes a call, transact or estimateGas on a contract function\n *\n * @method _executeMethod\n * @param {String} type the type this execute function should execute\n * @param {Boolean} makeRequest if true, it simply returns the request parameters, rather than executing it\n */\nContract.prototype._executeMethod = function _executeMethod() {\n    var _this = this, args = this._parent._processExecuteArguments.call(this, Array.prototype.slice.call(arguments), defer), defer = promiEvent((args.type !== 'send')), ethAccounts = _this.constructor._ethAccounts || _this._ethAccounts;\n    // simple return request for batch requests\n    if (args.generateRequest) {\n        var payload = {\n            params: [formatters.inputCallFormatter.call(this._parent, args.options)],\n            callback: args.callback\n        };\n        if (args.type === 'call') {\n            payload.params.push(formatters.inputDefaultBlockNumberFormatter.call(this._parent, args.defaultBlock));\n            payload.method = 'eth_call';\n            payload.format = this._parent._decodeMethodReturn.bind(null, this._method.outputs);\n        }\n        else {\n            payload.method = 'eth_sendTransaction';\n        }\n        return payload;\n    }\n    switch (args.type) {\n        case 'estimate':\n            var estimateGas = (new Method({\n                name: 'estimateGas',\n                call: 'eth_estimateGas',\n                params: 1,\n                inputFormatter: [formatters.inputCallFormatter],\n                outputFormatter: utils.hexToNumber,\n                requestManager: _this._parent._requestManager,\n                accounts: ethAccounts,\n                defaultAccount: _this._parent.defaultAccount,\n                defaultBlock: _this._parent.defaultBlock\n            })).createFunction();\n            return estimateGas(args.options, args.callback);\n        case 'call':\n            // TODO check errors: missing \"from\" should give error on deploy and send, call ?\n            var call = (new Method({\n                name: 'call',\n                call: 'eth_call',\n                params: 2,\n                inputFormatter: [formatters.inputCallFormatter, formatters.inputDefaultBlockNumberFormatter],\n                // add output formatter for decoding\n                outputFormatter: function (result) {\n                    return _this._parent._decodeMethodReturn(_this._method.outputs, result);\n                },\n                requestManager: _this._parent._requestManager,\n                accounts: ethAccounts,\n                defaultAccount: _this._parent.defaultAccount,\n                defaultBlock: _this._parent.defaultBlock,\n                handleRevert: _this._parent.handleRevert,\n                abiCoder: abi\n            })).createFunction();\n            return call(args.options, args.defaultBlock, args.callback);\n        case 'send':\n            // return error, if no \"from\" is specified\n            if (!utils.isAddress(args.options.from)) {\n                return utils._fireError(errors.ContractNoFromAddressDefinedError(), defer.eventEmitter, defer.reject, args.callback);\n            }\n            if (_.isBoolean(this._method.payable) && !this._method.payable && args.options.value && args.options.value > 0) {\n                return utils._fireError(new Error('Can not send value to non-payable contract method or constructor'), defer.eventEmitter, defer.reject, args.callback);\n            }\n            // make sure receipt logs are decoded\n            var extraFormatters = {\n                receiptFormatter: function (receipt) {\n                    if (_.isArray(receipt.logs)) {\n                        // decode logs\n                        var events = _.map(receipt.logs, function (log) {\n                            return _this._parent._decodeEventABI.call({\n                                name: 'ALLEVENTS',\n                                jsonInterface: _this._parent.options.jsonInterface\n                            }, log);\n                        });\n                        // make log names keys\n                        receipt.events = {};\n                        var count = 0;\n                        events.forEach(function (ev) {\n                            if (ev.event) {\n                                // if > 1 of the same event, don't overwrite any existing events\n                                if (receipt.events[ev.event]) {\n                                    if (Array.isArray(receipt.events[ev.event])) {\n                                        receipt.events[ev.event].push(ev);\n                                    }\n                                    else {\n                                        receipt.events[ev.event] = [receipt.events[ev.event], ev];\n                                    }\n                                }\n                                else {\n                                    receipt.events[ev.event] = ev;\n                                }\n                            }\n                            else {\n                                receipt.events[count] = ev;\n                                count++;\n                            }\n                        });\n                        delete receipt.logs;\n                    }\n                    return receipt;\n                },\n                contractDeployFormatter: function (receipt) {\n                    var newContract = _this._parent.clone();\n                    newContract.options.address = receipt.contractAddress;\n                    return newContract;\n                }\n            };\n            var sendTransaction = (new Method({\n                name: 'sendTransaction',\n                call: 'eth_sendTransaction',\n                params: 1,\n                inputFormatter: [formatters.inputTransactionFormatter],\n                requestManager: _this._parent._requestManager,\n                accounts: _this.constructor._ethAccounts || _this._ethAccounts,\n                defaultAccount: _this._parent.defaultAccount,\n                defaultBlock: _this._parent.defaultBlock,\n                transactionBlockTimeout: _this._parent.transactionBlockTimeout,\n                transactionConfirmationBlocks: _this._parent.transactionConfirmationBlocks,\n                transactionPollingTimeout: _this._parent.transactionPollingTimeout,\n                defaultCommon: _this._parent.defaultCommon,\n                defaultChain: _this._parent.defaultChain,\n                defaultHardfork: _this._parent.defaultHardfork,\n                handleRevert: _this._parent.handleRevert,\n                extraFormatters: extraFormatters,\n                abiCoder: abi\n            })).createFunction();\n            return sendTransaction(args.options, args.callback);\n        default:\n            throw new Error('Method \"' + args.type + '\" not implemented.');\n    }\n};\nmodule.exports = Contract;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2ViMy1ldGgtY29udHJhY3QvbGliL2luZGV4LmpzPzZlMTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsUUFBUSxtQkFBTyxDQUFDLDJEQUFZO0FBQzVCLFdBQVcsbUJBQU8sQ0FBQyx3REFBVztBQUM5QixhQUFhLG1CQUFPLENBQUMsc0VBQWtCO0FBQ3ZDLFlBQVksbUJBQU8sQ0FBQywwREFBWTtBQUNoQyxtQkFBbUIsc0hBQStDO0FBQ2xFLGlCQUFpQix3R0FBdUM7QUFDeEQsYUFBYSxvR0FBbUM7QUFDaEQsaUJBQWlCLG1CQUFPLENBQUMsOEVBQXNCO0FBQy9DLFVBQVUsbUJBQU8sQ0FBQyw4REFBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2ViMy1ldGgtY29udHJhY3QvbGliL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgY29udHJhY3QuanNcbiAqXG4gKiBUbyBpbml0aWFsaXplIGEgY29udHJhY3QgdXNlOlxuICpcbiAqICB2YXIgQ29udHJhY3QgPSByZXF1aXJlKCd3ZWIzLWV0aC1jb250cmFjdCcpO1xuICogIENvbnRyYWN0LnNldFByb3ZpZGVyKCd3czovL2xvY2FsaG9zdDo4NTQ2Jyk7XG4gKiAgdmFyIGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGFiaSwgYWRkcmVzcywgLi4uKTtcbiAqXG4gKiBAYXV0aG9yIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhlcmV1bS5vcmc+XG4gKiBAZGF0ZSAyMDE3XG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJ3dlYjMtY29yZScpO1xudmFyIE1ldGhvZCA9IHJlcXVpcmUoJ3dlYjMtY29yZS1tZXRob2QnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ3dlYjMtdXRpbHMnKTtcbnZhciBTdWJzY3JpcHRpb24gPSByZXF1aXJlKCd3ZWIzLWNvcmUtc3Vic2NyaXB0aW9ucycpLnN1YnNjcmlwdGlvbjtcbnZhciBmb3JtYXR0ZXJzID0gcmVxdWlyZSgnd2ViMy1jb3JlLWhlbHBlcnMnKS5mb3JtYXR0ZXJzO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJ3dlYjMtY29yZS1oZWxwZXJzJykuZXJyb3JzO1xudmFyIHByb21pRXZlbnQgPSByZXF1aXJlKCd3ZWIzLWNvcmUtcHJvbWlldmVudCcpO1xudmFyIGFiaSA9IHJlcXVpcmUoJ3dlYjMtZXRoLWFiaScpO1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNyZWF0ZSBuZXcgY29udHJhY3QgaW5zdGFuY2VcbiAqXG4gKiBAbWV0aG9kIENvbnRyYWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGpzb25JbnRlcmZhY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG52YXIgQ29udHJhY3QgPSBmdW5jdGlvbiBDb250cmFjdChqc29uSW50ZXJmYWNlLCBhZGRyZXNzLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcywgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbnRyYWN0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSB1c2UgdGhlIFwibmV3XCIga2V5d29yZCB0byBpbnN0YW50aWF0ZSBhIHdlYjMuZXRoLkNvbnRyYWN0KCkgb2JqZWN0IScpO1xuICAgIH1cbiAgICB0aGlzLnNldFByb3ZpZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb3JlLnBhY2thZ2VJbml0KF90aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBfdGhpcy5jbGVhclN1YnNjcmlwdGlvbnMgPSBfdGhpcy5fcmVxdWVzdE1hbmFnZXIuY2xlYXJTdWJzY3JpcHRpb25zO1xuICAgIH07XG4gICAgLy8gc2V0cyBfcmVxdWVzdG1hbmFnZXJcbiAgICBjb3JlLnBhY2thZ2VJbml0KHRoaXMsIFt0aGlzLmNvbnN0cnVjdG9yXSk7XG4gICAgdGhpcy5jbGVhclN1YnNjcmlwdGlvbnMgPSB0aGlzLl9yZXF1ZXN0TWFuYWdlci5jbGVhclN1YnNjcmlwdGlvbnM7XG4gICAgaWYgKCFqc29uSW50ZXJmYWNlIHx8ICEoQXJyYXkuaXNBcnJheShqc29uSW50ZXJmYWNlKSkpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JzLkNvbnRyYWN0TWlzc2luZ0FCSUVycm9yKCk7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSB0aGUgb3B0aW9ucyBvYmplY3RcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB2YXIgbGFzdEFyZyA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICBpZiAoXy5pc09iamVjdChsYXN0QXJnKSAmJiAhXy5pc0FycmF5KGxhc3RBcmcpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBsYXN0QXJnO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBfLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuX2dldE9yU2V0RGVmYXVsdE9wdGlvbnMob3B0aW9ucykpO1xuICAgICAgICBpZiAoXy5pc09iamVjdChhZGRyZXNzKSkge1xuICAgICAgICAgICAgYWRkcmVzcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc2V0IGFkZHJlc3NcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5vcHRpb25zLCAnYWRkcmVzcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9hZGRyZXNzID0gdXRpbHMudG9DaGVja3N1bUFkZHJlc3MoZm9ybWF0dGVycy5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2FkZHJlc3M7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvLyBhZGQgbWV0aG9kIGFuZCBldmVudCBzaWduYXR1cmVzLCB3aGVuIHRoZSBqc29uSW50ZXJmYWNlIGdldHMgc2V0XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMub3B0aW9ucywgJ2pzb25JbnRlcmZhY2UnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBfdGhpcy5tZXRob2RzID0ge307XG4gICAgICAgICAgICBfdGhpcy5ldmVudHMgPSB7fTtcbiAgICAgICAgICAgIF90aGlzLl9qc29uSW50ZXJmYWNlID0gdmFsdWUubWFwKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnVuYywgZnVuY05hbWU7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBjb25zdGFudCBhbmQgcGF5YWJsZSBiYWNrd2FyZHMgY29tcGF0aWJsZVxuICAgICAgICAgICAgICAgIG1ldGhvZC5jb25zdGFudCA9IChtZXRob2Quc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCBtZXRob2Quc3RhdGVNdXRhYmlsaXR5ID09PSBcInB1cmVcIiB8fCBtZXRob2QuY29uc3RhbnQpO1xuICAgICAgICAgICAgICAgIG1ldGhvZC5wYXlhYmxlID0gKG1ldGhvZC5zdGF0ZU11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiIHx8IG1ldGhvZC5wYXlhYmxlKTtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWUgPSB1dGlscy5fanNvbkludGVyZmFjZU1ldGhvZFRvU3RyaW5nKG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZC50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZC5zaWduYXR1cmUgPSBhYmkuZW5jb2RlRnVuY3Rpb25TaWduYXR1cmUoZnVuY05hbWUpO1xuICAgICAgICAgICAgICAgICAgICBmdW5jID0gX3RoaXMuX2NyZWF0ZVR4T2JqZWN0LmJpbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IF90aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgbWV0aG9kIG9ubHkgaWYgbm90IG9uZSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLm1ldGhvZHNbbWV0aG9kLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tZXRob2RzW21ldGhvZC5uYW1lXSA9IGZ1bmM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FzY2FkZUZ1bmMgPSBfdGhpcy5fY3JlYXRlVHhPYmplY3QuYmluZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBfdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0TWV0aG9kOiBfdGhpcy5tZXRob2RzW21ldGhvZC5uYW1lXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tZXRob2RzW21ldGhvZC5uYW1lXSA9IGNhc2NhZGVGdW5jO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmluaXRlbHkgYWRkIHRoZSBtZXRob2QgYmFzZWQgb24gaXRzIHNpZ25hdHVyZVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tZXRob2RzW21ldGhvZC5zaWduYXR1cmVdID0gZnVuYztcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIG1ldGhvZCBieSBuYW1lXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1ldGhvZHNbZnVuY05hbWVdID0gZnVuYztcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlbnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWV0aG9kLnR5cGUgPT09ICdldmVudCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kLnNpZ25hdHVyZSA9IGFiaS5lbmNvZGVFdmVudFNpZ25hdHVyZShmdW5jTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudCA9IF90aGlzLl9vbi5iaW5kKF90aGlzLCBtZXRob2Quc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIG1ldGhvZCBvbmx5IGlmIG5vdCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmV2ZW50c1ttZXRob2QubmFtZV0gfHwgX3RoaXMuZXZlbnRzW21ldGhvZC5uYW1lXS5uYW1lID09PSAnYm91bmQgJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50c1ttZXRob2QubmFtZV0gPSBldmVudDtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVmaW5pdGVseSBhZGQgdGhlIG1ldGhvZCBiYXNlZCBvbiBpdHMgc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50c1ttZXRob2Quc2lnbmF0dXJlXSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgZXZlbnQgYnkgbmFtZVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudHNbZnVuY05hbWVdID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGFkZCBhbGxFdmVudHNcbiAgICAgICAgICAgIF90aGlzLmV2ZW50cy5hbGxFdmVudHMgPSBfdGhpcy5fb24uYmluZChfdGhpcywgJ2FsbGV2ZW50cycpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9qc29uSW50ZXJmYWNlO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fanNvbkludGVyZmFjZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8vIGdldCBkZWZhdWx0IGFjY291bnQgZnJvbSB0aGUgQ2xhc3NcbiAgICB2YXIgZGVmYXVsdEFjY291bnQgPSB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRBY2NvdW50O1xuICAgIHZhciBkZWZhdWx0QmxvY2sgPSB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRCbG9jayB8fCAnbGF0ZXN0JztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2hhbmRsZVJldmVydCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5oYW5kbGVSZXZlcnQgPT09IGZhbHNlIHx8IF90aGlzLm9wdGlvbnMuaGFuZGxlUmV2ZXJ0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm9wdGlvbnMuaGFuZGxlUmV2ZXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuaGFuZGxlUmV2ZXJ0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIF90aGlzLm9wdGlvbnMuaGFuZGxlUmV2ZXJ0ID0gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdkZWZhdWx0Q29tbW9uJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5vcHRpb25zLmNvbW1vbiB8fCB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRDb21tb247XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgX3RoaXMub3B0aW9ucy5jb21tb24gPSB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2RlZmF1bHRIYXJkZm9yaycsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMub3B0aW9ucy5oYXJkZm9yayB8fCB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRIYXJkZm9yaztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBfdGhpcy5vcHRpb25zLmhhcmRmb3JrID0gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdkZWZhdWx0Q2hhaW4nLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm9wdGlvbnMuY2hhaW4gfHwgdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0Q2hhaW47XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgX3RoaXMub3B0aW9ucy5jaGFpbiA9IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHJhbnNhY3Rpb25Qb2xsaW5nVGltZW91dCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy50cmFuc2FjdGlvblBvbGxpbmdUaW1lb3V0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm9wdGlvbnMudHJhbnNhY3Rpb25Qb2xsaW5nVGltZW91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5vcHRpb25zLnRyYW5zYWN0aW9uUG9sbGluZ1RpbWVvdXQgfHwgdGhpcy5jb25zdHJ1Y3Rvci50cmFuc2FjdGlvblBvbGxpbmdUaW1lb3V0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIF90aGlzLm9wdGlvbnMudHJhbnNhY3Rpb25Qb2xsaW5nVGltZW91dCA9IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHJhbnNhY3Rpb25Db25maXJtYXRpb25CbG9ja3MnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMudHJhbnNhY3Rpb25Db25maXJtYXRpb25CbG9ja3MgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMub3B0aW9ucy50cmFuc2FjdGlvbkNvbmZpcm1hdGlvbkJsb2NrcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5vcHRpb25zLnRyYW5zYWN0aW9uQ29uZmlybWF0aW9uQmxvY2tzIHx8IHRoaXMuY29uc3RydWN0b3IudHJhbnNhY3Rpb25Db25maXJtYXRpb25CbG9ja3M7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgX3RoaXMub3B0aW9ucy50cmFuc2FjdGlvbkNvbmZpcm1hdGlvbkJsb2NrcyA9IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHJhbnNhY3Rpb25CbG9ja1RpbWVvdXQnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMudHJhbnNhY3Rpb25CbG9ja1RpbWVvdXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMub3B0aW9ucy50cmFuc2FjdGlvbkJsb2NrVGltZW91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5vcHRpb25zLnRyYW5zYWN0aW9uQmxvY2tUaW1lb3V0IHx8IHRoaXMuY29uc3RydWN0b3IudHJhbnNhY3Rpb25CbG9ja1RpbWVvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgX3RoaXMub3B0aW9ucy50cmFuc2FjdGlvbkJsb2NrVGltZW91dCA9IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZGVmYXVsdEFjY291bnQnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRBY2NvdW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0QWNjb3VudCA9IHV0aWxzLnRvQ2hlY2tzdW1BZGRyZXNzKGZvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyKHZhbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZGVmYXVsdEJsb2NrJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0QmxvY2s7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgZGVmYXVsdEJsb2NrID0gdmFsO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8vIHByb3BlcnRpZXNcbiAgICB0aGlzLm1ldGhvZHMgPSB7fTtcbiAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgIHRoaXMuX2FkZHJlc3MgPSBudWxsO1xuICAgIHRoaXMuX2pzb25JbnRlcmZhY2UgPSBbXTtcbiAgICAvLyBzZXQgZ2V0dGVyL3NldHRlciBwcm9wZXJ0aWVzXG4gICAgdGhpcy5vcHRpb25zLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgIHRoaXMub3B0aW9ucy5qc29uSW50ZXJmYWNlID0ganNvbkludGVyZmFjZTtcbn07XG4vKipcbiAqIFNldHMgdGhlIG5ldyBwcm92aWRlciwgY3JlYXRlcyBhIG5ldyByZXF1ZXN0TWFuYWdlciwgcmVnaXN0ZXJzIHRoZSBcImRhdGFcIiBsaXN0ZW5lciBvbiB0aGUgcHJvdmlkZXIgYW5kIHNldHMgdGhlXG4gKiBhY2NvdW50cyBtb2R1bGUgZm9yIHRoZSBDb250cmFjdCBjbGFzcy5cbiAqXG4gKiBAbWV0aG9kIHNldFByb3ZpZGVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8cHJvdmlkZXJ9IHByb3ZpZGVyXG4gKiBAcGFyYW0ge0FjY291bnRzfSBhY2NvdW50c1xuICpcbiAqIEByZXR1cm5zIHZvaWRcbiAqL1xuQ29udHJhY3Quc2V0UHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIsIGFjY291bnRzKSB7XG4gICAgLy8gQ29udHJhY3QuY3VycmVudFByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgY29yZS5wYWNrYWdlSW5pdCh0aGlzLCBbcHJvdmlkZXJdKTtcbiAgICB0aGlzLl9ldGhBY2NvdW50cyA9IGFjY291bnRzO1xufTtcbi8qKlxuICogR2V0IHRoZSBjYWxsYmFjayBhbmQgbW9kaWZ5IHRoZSBhcnJheSBpZiBuZWNlc3NhcnlcbiAqXG4gKiBAbWV0aG9kIF9nZXRDYWxsYmFja1xuICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBjYWxsYmFja1xuICovXG5Db250cmFjdC5wcm90b3R5cGUuX2dldENhbGxiYWNrID0gZnVuY3Rpb24gZ2V0Q2FsbGJhY2soYXJncykge1xuICAgIGlmIChhcmdzICYmIF8uaXNGdW5jdGlvbihhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHJldHVybiBhcmdzLnBvcCgpOyAvLyBtb2RpZnkgdGhlIGFyZ3MgYXJyYXkhXG4gICAgfVxufTtcbi8qKlxuICogQ2hlY2tzIHRoYXQgbm8gbGlzdGVuZXIgd2l0aCBuYW1lIFwibmV3TGlzdGVuZXJcIiBvciBcInJlbW92ZUxpc3RlbmVyXCIgaXMgYWRkZWQuXG4gKlxuICogQG1ldGhvZCBfY2hlY2tMaXN0ZW5lclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgY29udHJhY3QgaW5zdGFuY2VcbiAqL1xuQ29udHJhY3QucHJvdG90eXBlLl9jaGVja0xpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50ID09PSB0eXBlKSB7XG4gICAgICAgIHRocm93IGVycm9ycy5Db250cmFjdFJlc2VydmVkRXZlbnRFcnJvcih0eXBlKTtcbiAgICB9XG59O1xuLyoqXG4gKiBVc2UgZGVmYXVsdCB2YWx1ZXMsIGlmIG9wdGlvbnMgYXJlIG5vdCBhdmFpbGFibGVcbiAqXG4gKiBAbWV0aG9kIF9nZXRPclNldERlZmF1bHRPcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyBnaXZlZCBieSB0aGUgdXNlclxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgb3B0aW9ucyB3aXRoIGdhcHMgZmlsbGVkIGJ5IGRlZmF1bHRzXG4gKi9cbkNvbnRyYWN0LnByb3RvdHlwZS5fZ2V0T3JTZXREZWZhdWx0T3B0aW9ucyA9IGZ1bmN0aW9uIGdldE9yU2V0RGVmYXVsdE9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciBnYXNQcmljZSA9IG9wdGlvbnMuZ2FzUHJpY2UgPyBTdHJpbmcob3B0aW9ucy5nYXNQcmljZSkgOiBudWxsO1xuICAgIHZhciBmcm9tID0gb3B0aW9ucy5mcm9tID8gdXRpbHMudG9DaGVja3N1bUFkZHJlc3MoZm9ybWF0dGVycy5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIob3B0aW9ucy5mcm9tKSkgOiBudWxsO1xuICAgIG9wdGlvbnMuZGF0YSA9IG9wdGlvbnMuZGF0YSB8fCB0aGlzLm9wdGlvbnMuZGF0YTtcbiAgICBvcHRpb25zLmZyb20gPSBmcm9tIHx8IHRoaXMub3B0aW9ucy5mcm9tO1xuICAgIG9wdGlvbnMuZ2FzUHJpY2UgPSBnYXNQcmljZSB8fCB0aGlzLm9wdGlvbnMuZ2FzUHJpY2U7XG4gICAgb3B0aW9ucy5nYXMgPSBvcHRpb25zLmdhcyB8fCBvcHRpb25zLmdhc0xpbWl0IHx8IHRoaXMub3B0aW9ucy5nYXM7XG4gICAgLy8gVE9ETyByZXBsYWNlIHdpdGggb25seSBnYXNMaW1pdD9cbiAgICBkZWxldGUgb3B0aW9ucy5nYXNMaW1pdDtcbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGVuY29kZSBpbmRleGVkIHBhcmFtcyBhbmQgb3B0aW9ucyB0byBvbmUgZmluYWwgb2JqZWN0XG4gKlxuICogQG1ldGhvZCBfZW5jb2RlRXZlbnRBQklcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gZXZlcnl0aGluZyBjb21iaW5lZCB0b2dldGhlciBhbmQgZW5jb2RlZFxuICovXG5Db250cmFjdC5wcm90b3R5cGUuX2VuY29kZUV2ZW50QUJJID0gZnVuY3Rpb24gKGV2ZW50LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyIHx8IHt9LCByZXN1bHQgPSB7fTtcbiAgICBbJ2Zyb21CbG9jaycsICd0b0Jsb2NrJ10uZmlsdGVyKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zW2ZdICE9PSB1bmRlZmluZWQ7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICByZXN1bHRbZl0gPSBmb3JtYXR0ZXJzLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIob3B0aW9uc1tmXSk7XG4gICAgfSk7XG4gICAgLy8gdXNlIGdpdmVuIHRvcGljc1xuICAgIGlmIChfLmlzQXJyYXkob3B0aW9ucy50b3BpY3MpKSB7XG4gICAgICAgIHJlc3VsdC50b3BpY3MgPSBvcHRpb25zLnRvcGljcztcbiAgICAgICAgLy8gY3JlYXRlIHRvcGljcyBiYXNlZCBvbiBmaWx0ZXJcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC50b3BpY3MgPSBbXTtcbiAgICAgICAgLy8gYWRkIGV2ZW50IHNpZ25hdHVyZVxuICAgICAgICBpZiAoZXZlbnQgJiYgIWV2ZW50LmFub255bW91cyAmJiBldmVudC5uYW1lICE9PSAnQUxMRVZFTlRTJykge1xuICAgICAgICAgICAgcmVzdWx0LnRvcGljcy5wdXNoKGV2ZW50LnNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGV2ZW50IHRvcGljcyAoaW5kZXhlZCBhcmd1bWVudHMpXG4gICAgICAgIGlmIChldmVudC5uYW1lICE9PSAnQUxMRVZFTlRTJykge1xuICAgICAgICAgICAgdmFyIGluZGV4ZWRUb3BpY3MgPSBldmVudC5pbnB1dHMuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkuaW5kZXhlZCA9PT0gdHJ1ZTtcbiAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGZpbHRlcltpLm5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93ZWIzLmpzL2lzc3Vlcy8zNDRcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBkZWFsIHByb3Blcmx5IHdpdGggY29tcG9uZW50c1xuICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhYmkuZW5jb2RlUGFyYW1ldGVyKGkudHlwZSwgdik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWJpLmVuY29kZVBhcmFtZXRlcihpLnR5cGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0LnRvcGljcyA9IHJlc3VsdC50b3BpY3MuY29uY2F0KGluZGV4ZWRUb3BpY3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0LnRvcGljcy5sZW5ndGgpXG4gICAgICAgICAgICBkZWxldGUgcmVzdWx0LnRvcGljcztcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hZGRyZXNzKSB7XG4gICAgICAgIHJlc3VsdC5hZGRyZXNzID0gdGhpcy5vcHRpb25zLmFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGRlY29kZSBpbmRleGVkIHBhcmFtcyBhbmQgb3B0aW9uc1xuICpcbiAqIEBtZXRob2QgX2RlY29kZUV2ZW50QUJJXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHJldHVybiB7T2JqZWN0fSByZXN1bHQgb2JqZWN0IHdpdGggZGVjb2RlZCBpbmRleGVkICYmIG5vdCBpbmRleGVkIHBhcmFtc1xuICovXG5Db250cmFjdC5wcm90b3R5cGUuX2RlY29kZUV2ZW50QUJJID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzO1xuICAgIGRhdGEuZGF0YSA9IGRhdGEuZGF0YSB8fCAnJztcbiAgICBkYXRhLnRvcGljcyA9IGRhdGEudG9waWNzIHx8IFtdO1xuICAgIHZhciByZXN1bHQgPSBmb3JtYXR0ZXJzLm91dHB1dExvZ0Zvcm1hdHRlcihkYXRhKTtcbiAgICAvLyBpZiBhbGxFdmVudHMgZ2V0IHRoZSByaWdodCBldmVudFxuICAgIGlmIChldmVudC5uYW1lID09PSAnQUxMRVZFTlRTJykge1xuICAgICAgICBldmVudCA9IGV2ZW50Lmpzb25JbnRlcmZhY2UuZmluZChmdW5jdGlvbiAoaW50Zikge1xuICAgICAgICAgICAgcmV0dXJuIChpbnRmLnNpZ25hdHVyZSA9PT0gZGF0YS50b3BpY3NbMF0pO1xuICAgICAgICB9KSB8fCB7IGFub255bW91czogdHJ1ZSB9O1xuICAgIH1cbiAgICAvLyBjcmVhdGUgZW1wdHkgaW5wdXRzIGlmIG5vbmUgYXJlIHByZXNlbnQgKGUuZy4gYW5vbnltb3VzIGV2ZW50cyBvbiBhbGxFdmVudHMpXG4gICAgZXZlbnQuaW5wdXRzID0gZXZlbnQuaW5wdXRzIHx8IFtdO1xuICAgIC8vIEhhbmRsZSBjYXNlIHdoZXJlIGFuIGV2ZW50IHNpZ25hdHVyZSBzaGFkb3dzIHRoZSBjdXJyZW50IEFCSSB3aXRoIG5vbi1pZGVudGljYWxcbiAgICAvLyBhcmcgaW5kZXhpbmcuIElmICMgb2YgdG9waWNzIGRvZXNuJ3QgbWF0Y2gsIGV2ZW50IGlzIGFub24uXG4gICAgaWYgKCFldmVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgbGV0IGluZGV4ZWRJbnB1dHMgPSAwO1xuICAgICAgICBldmVudC5pbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBpbnB1dC5pbmRleGVkID8gaW5kZXhlZElucHV0cysrIDogbnVsbCk7XG4gICAgICAgIGlmIChpbmRleGVkSW5wdXRzID4gMCAmJiAoZGF0YS50b3BpY3MubGVuZ3RoICE9PSBpbmRleGVkSW5wdXRzICsgMSkpIHtcbiAgICAgICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIGFub255bW91czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBhcmdUb3BpY3MgPSBldmVudC5hbm9ueW1vdXMgPyBkYXRhLnRvcGljcyA6IGRhdGEudG9waWNzLnNsaWNlKDEpO1xuICAgIHJlc3VsdC5yZXR1cm5WYWx1ZXMgPSBhYmkuZGVjb2RlTG9nKGV2ZW50LmlucHV0cywgZGF0YS5kYXRhLCBhcmdUb3BpY3MpO1xuICAgIGRlbGV0ZSByZXN1bHQucmV0dXJuVmFsdWVzLl9fbGVuZ3RoX187XG4gICAgLy8gYWRkIG5hbWVcbiAgICByZXN1bHQuZXZlbnQgPSBldmVudC5uYW1lO1xuICAgIC8vIGFkZCBzaWduYXR1cmVcbiAgICByZXN1bHQuc2lnbmF0dXJlID0gKGV2ZW50LmFub255bW91cyB8fCAhZGF0YS50b3BpY3NbMF0pID8gbnVsbCA6IGRhdGEudG9waWNzWzBdO1xuICAgIC8vIG1vdmUgdGhlIGRhdGEgYW5kIHRvcGljcyB0byBcInJhd1wiXG4gICAgcmVzdWx0LnJhdyA9IHtcbiAgICAgICAgZGF0YTogcmVzdWx0LmRhdGEsXG4gICAgICAgIHRvcGljczogcmVzdWx0LnRvcGljc1xuICAgIH07XG4gICAgZGVsZXRlIHJlc3VsdC5kYXRhO1xuICAgIGRlbGV0ZSByZXN1bHQudG9waWNzO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBFbmNvZGVzIGFuIEFCSSBmb3IgYSBtZXRob2QsIGluY2x1ZGluZyBzaWduYXR1cmUgb3IgdGhlIG1ldGhvZC5cbiAqIE9yIHdoZW4gY29uc3RydWN0b3IgZW5jb2RlcyBvbmx5IHRoZSBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzLlxuICpcbiAqIEBtZXRob2QgX2VuY29kZU1ldGhvZEFCSVxuICogQHBhcmFtIHtNaXhlZH0gYXJncyB0aGUgYXJndW1lbnRzIHRvIGVuY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IHRoZSBlbmNvZGVkIEFCSVxuICovXG5Db250cmFjdC5wcm90b3R5cGUuX2VuY29kZU1ldGhvZEFCSSA9IGZ1bmN0aW9uIF9lbmNvZGVNZXRob2RBQkkoKSB7XG4gICAgdmFyIG1ldGhvZFNpZ25hdHVyZSA9IHRoaXMuX21ldGhvZC5zaWduYXR1cmUsIGFyZ3MgPSB0aGlzLmFyZ3VtZW50cyB8fCBbXTtcbiAgICB2YXIgc2lnbmF0dXJlID0gZmFsc2UsIHBhcmFtc0FCSSA9IHRoaXMuX3BhcmVudC5vcHRpb25zLmpzb25JbnRlcmZhY2UuZmlsdGVyKGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgIHJldHVybiAoKG1ldGhvZFNpZ25hdHVyZSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiBqc29uLnR5cGUgPT09IG1ldGhvZFNpZ25hdHVyZSkgfHxcbiAgICAgICAgICAgICgoanNvbi5zaWduYXR1cmUgPT09IG1ldGhvZFNpZ25hdHVyZSB8fCBqc29uLnNpZ25hdHVyZSA9PT0gbWV0aG9kU2lnbmF0dXJlLnJlcGxhY2UoJzB4JywgJycpIHx8IGpzb24ubmFtZSA9PT0gbWV0aG9kU2lnbmF0dXJlKSAmJiBqc29uLnR5cGUgPT09ICdmdW5jdGlvbicpKTtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgdmFyIGlucHV0TGVuZ3RoID0gKF8uaXNBcnJheShqc29uLmlucHV0cykpID8ganNvbi5pbnB1dHMubGVuZ3RoIDogMDtcbiAgICAgICAgaWYgKGlucHV0TGVuZ3RoICE9PSBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBpcyBub3QgbWF0Y2hpbmcgdGhlIG1ldGhvZHMgcmVxdWlyZWQgbnVtYmVyLiBZb3UgbmVlZCB0byBwYXNzICcgKyBpbnB1dExlbmd0aCArICcgYXJndW1lbnRzLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc29uLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNpZ25hdHVyZSA9IGpzb24uc2lnbmF0dXJlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfLmlzQXJyYXkoanNvbi5pbnB1dHMpID8ganNvbi5pbnB1dHMgOiBbXTtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKGlucHV0cykge1xuICAgICAgICByZXR1cm4gYWJpLmVuY29kZVBhcmFtZXRlcnMoaW5wdXRzLCBhcmdzKS5yZXBsYWNlKCcweCcsICcnKTtcbiAgICB9KVswXSB8fCAnJztcbiAgICAvLyByZXR1cm4gY29uc3RydWN0b3JcbiAgICBpZiAobWV0aG9kU2lnbmF0dXJlID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgIGlmICghdGhpcy5fZGVwbG95RGF0YSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNvbnRyYWN0IGhhcyBubyBjb250cmFjdCBkYXRhIG9wdGlvbiBzZXQuIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIGFwcGVuZCB0aGUgY29uc3RydWN0b3IgcGFyYW1ldGVycy4nKTtcbiAgICAgICAgaWYgKCF0aGlzLl9kZXBsb3lEYXRhLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlcGxveURhdGEgPSAnMHgnICsgdGhpcy5fZGVwbG95RGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVwbG95RGF0YSArIHBhcmFtc0FCSTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIG1ldGhvZFxuICAgIHZhciByZXR1cm5WYWx1ZSA9IChzaWduYXR1cmUpID8gc2lnbmF0dXJlICsgcGFyYW1zQUJJIDogcGFyYW1zQUJJO1xuICAgIGlmICghcmV0dXJuVmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZG5cXCd0IGZpbmQgYSBtYXRjaGluZyBjb250cmFjdCBtZXRob2QgbmFtZWQgXCInICsgdGhpcy5fbWV0aG9kLm5hbWUgKyAnXCIuJyk7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbn07XG4vKipcbiAqIERlY29kZSBtZXRob2QgcmV0dXJuIHZhbHVlc1xuICpcbiAqIEBtZXRob2QgX2RlY29kZU1ldGhvZFJldHVyblxuICogQHBhcmFtIHtBcnJheX0gb3V0cHV0c1xuICogQHBhcmFtIHtTdHJpbmd9IHJldHVyblZhbHVlc1xuICogQHJldHVybiB7T2JqZWN0fSBkZWNvZGVkIG91dHB1dCByZXR1cm4gdmFsdWVzXG4gKi9cbkNvbnRyYWN0LnByb3RvdHlwZS5fZGVjb2RlTWV0aG9kUmV0dXJuID0gZnVuY3Rpb24gKG91dHB1dHMsIHJldHVyblZhbHVlcykge1xuICAgIGlmICghcmV0dXJuVmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm5WYWx1ZXMgPSByZXR1cm5WYWx1ZXMubGVuZ3RoID49IDIgPyByZXR1cm5WYWx1ZXMuc2xpY2UoMikgOiByZXR1cm5WYWx1ZXM7XG4gICAgdmFyIHJlc3VsdCA9IGFiaS5kZWNvZGVQYXJhbWV0ZXJzKG91dHB1dHMsIHJldHVyblZhbHVlcyk7XG4gICAgaWYgKHJlc3VsdC5fX2xlbmd0aF9fID09PSAxKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgfVxuICAgIGRlbGV0ZSByZXN1bHQuX19sZW5ndGhfXztcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogRGVwbG95cyBhIGNvbnRyYWN0IGFuZCBmaXJlIGV2ZW50cyBiYXNlZCBvbiBpdHMgc3RhdGU6IHRyYW5zYWN0aW9uSGFzaCwgcmVjZWlwdFxuICpcbiAqIEFsbCBldmVudCBsaXN0ZW5lcnMgd2lsbCBiZSByZW1vdmVkLCBvbmNlIHRoZSBsYXN0IHBvc3NpYmxlIGV2ZW50IGlzIGZpcmVkIChcImVycm9yXCIsIG9yIFwicmVjZWlwdFwiKVxuICpcbiAqIEBtZXRob2QgZGVwbG95XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge09iamVjdH0gRXZlbnRFbWl0dGVyIHBvc3NpYmxlIGV2ZW50cyBhcmUgXCJlcnJvclwiLCBcInRyYW5zYWN0aW9uSGFzaFwiIGFuZCBcInJlY2VpcHRcIlxuICovXG5Db250cmFjdC5wcm90b3R5cGUuZGVwbG95ID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5hcmd1bWVudHMgPSBvcHRpb25zLmFyZ3VtZW50cyB8fCBbXTtcbiAgICBvcHRpb25zID0gdGhpcy5fZ2V0T3JTZXREZWZhdWx0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAvLyB0aHJvdyBlcnJvciwgaWYgbm8gXCJkYXRhXCIgaXMgc3BlY2lmaWVkXG4gICAgaWYgKCFvcHRpb25zLmRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9ycy5Db250cmFjdE1pc3NpbmdEZXBsb3lEYXRhRXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JzLkNvbnRyYWN0TWlzc2luZ0RlcGxveURhdGFFcnJvcigpO1xuICAgIH1cbiAgICB2YXIgY29uc3RydWN0b3IgPSBfLmZpbmQodGhpcy5vcHRpb25zLmpzb25JbnRlcmZhY2UsIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIChtZXRob2QudHlwZSA9PT0gJ2NvbnN0cnVjdG9yJyk7XG4gICAgfSkgfHwge307XG4gICAgY29uc3RydWN0b3Iuc2lnbmF0dXJlID0gJ2NvbnN0cnVjdG9yJztcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlVHhPYmplY3QuYXBwbHkoe1xuICAgICAgICBtZXRob2Q6IGNvbnN0cnVjdG9yLFxuICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgIGRlcGxveURhdGE6IG9wdGlvbnMuZGF0YSxcbiAgICAgICAgX2V0aEFjY291bnRzOiB0aGlzLmNvbnN0cnVjdG9yLl9ldGhBY2NvdW50c1xuICAgIH0sIG9wdGlvbnMuYXJndW1lbnRzKTtcbn07XG4vKipcbiAqIEdldHMgdGhlIGV2ZW50IHNpZ25hdHVyZSBhbmQgb3V0cHV0Rm9ybWF0dGVyc1xuICpcbiAqIEBtZXRob2QgX2dlbmVyYXRlRXZlbnRPcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7T2JqZWN0fSB0aGUgZXZlbnQgb3B0aW9ucyBvYmplY3RcbiAqL1xuQ29udHJhY3QucHJvdG90eXBlLl9nZW5lcmF0ZUV2ZW50T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgLy8gZ2V0IHRoZSBjYWxsYmFja1xuICAgIHZhciBjYWxsYmFjayA9IHRoaXMuX2dldENhbGxiYWNrKGFyZ3MpO1xuICAgIC8vIGdldCB0aGUgb3B0aW9uc1xuICAgIHZhciBvcHRpb25zID0gKF8uaXNPYmplY3QoYXJnc1thcmdzLmxlbmd0aCAtIDFdKSkgPyBhcmdzLnBvcCgpIDoge307XG4gICAgdmFyIGV2ZW50TmFtZSA9IChfLmlzU3RyaW5nKGFyZ3NbMF0pKSA/IGFyZ3NbMF0gOiAnYWxsZXZlbnRzJztcbiAgICB2YXIgZXZlbnQgPSAoZXZlbnROYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhbGxldmVudHMnKSA/IHtcbiAgICAgICAgbmFtZTogJ0FMTEVWRU5UUycsXG4gICAgICAgIGpzb25JbnRlcmZhY2U6IHRoaXMub3B0aW9ucy5qc29uSW50ZXJmYWNlXG4gICAgfSA6IHRoaXMub3B0aW9ucy5qc29uSW50ZXJmYWNlLmZpbmQoZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIChqc29uLnR5cGUgPT09ICdldmVudCcgJiYgKGpzb24ubmFtZSA9PT0gZXZlbnROYW1lIHx8IGpzb24uc2lnbmF0dXJlID09PSAnMHgnICsgZXZlbnROYW1lLnJlcGxhY2UoJzB4JywgJycpKSk7XG4gICAgfSk7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgICB0aHJvdyBlcnJvcnMuQ29udHJhY3RFdmVudERvZXNOb3RFeGlzdEVycm9yKGV2ZW50TmFtZSk7XG4gICAgfVxuICAgIGlmICghdXRpbHMuaXNBZGRyZXNzKHRoaXMub3B0aW9ucy5hZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBlcnJvcnMuQ29udHJhY3ROb0FkZHJlc3NEZWZpbmVkRXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGFyYW1zOiB0aGlzLl9lbmNvZGVFdmVudEFCSShldmVudCwgb3B0aW9ucyksXG4gICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgfTtcbn07XG4vKipcbiAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIGFuZCBjcmVhdGVzIGEgc3Vic2NyaXB0aW9uLCBhbmQgcmVtb3ZlIGl0IG9uY2UgaXRzIGZpcmVkLlxuICpcbiAqIEBtZXRob2QgY2xvbmVcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGV2ZW50IHN1YnNjcmlwdGlvblxuICovXG5Db250cmFjdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMub3B0aW9ucy5qc29uSW50ZXJmYWNlLCB0aGlzLm9wdGlvbnMuYWRkcmVzcywgdGhpcy5vcHRpb25zKTtcbn07XG4vKipcbiAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIGFuZCBjcmVhdGVzIGEgc3Vic2NyaXB0aW9uLCBhbmQgcmVtb3ZlIGl0IG9uY2UgaXRzIGZpcmVkLlxuICpcbiAqIEBtZXRob2Qgb25jZVxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGV2ZW50IHN1YnNjcmlwdGlvblxuICovXG5Db250cmFjdC5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIChldmVudCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgLy8gZ2V0IHRoZSBjYWxsYmFja1xuICAgIGNhbGxiYWNrID0gdGhpcy5fZ2V0Q2FsbGJhY2soYXJncyk7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICB0aHJvdyBlcnJvcnMuQ29udHJhY3RPbmNlUmVxdWlyZXNDYWxsYmFja0Vycm9yKCk7XG4gICAgfVxuICAgIC8vIGRvbid0IGFsbG93IGZyb21CbG9ja1xuICAgIGlmIChvcHRpb25zKVxuICAgICAgICBkZWxldGUgb3B0aW9ucy5mcm9tQmxvY2s7XG4gICAgLy8gZG9uJ3QgcmV0dXJuIGFzIG9uY2Ugc2hvdWxkbid0IHByb3ZpZGUgXCJvblwiXG4gICAgdGhpcy5fb24oZXZlbnQsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIsIHJlcywgc3ViKSB7XG4gICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXMsIHN1Yik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbi8qKlxuICogQWRkcyBldmVudCBsaXN0ZW5lcnMgYW5kIGNyZWF0ZXMgYSBzdWJzY3JpcHRpb24uXG4gKlxuICogQG1ldGhvZCBfb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICpcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGV2ZW50IHN1YnNjcmlwdGlvblxuICovXG5Db250cmFjdC5wcm90b3R5cGUuX29uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdWJPcHRpb25zID0gdGhpcy5fZ2VuZXJhdGVFdmVudE9wdGlvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoc3ViT3B0aW9ucy5wYXJhbXMgJiYgc3ViT3B0aW9ucy5wYXJhbXMudG9CbG9jaykge1xuICAgICAgICBkZWxldGUgc3ViT3B0aW9ucy5wYXJhbXMudG9CbG9jaztcbiAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIG9wdGlvbjogdG9CbG9jay4gVXNlIGdldFBhc3RFdmVudHMgZm9yIHNwZWNpZmljIHJhbmdlLicpO1xuICAgIH1cbiAgICAvLyBwcmV2ZW50IHRoZSBldmVudCBcIm5ld0xpc3RlbmVyXCIgYW5kIFwicmVtb3ZlTGlzdGVuZXJcIiBmcm9tIGJlaW5nIG92ZXJ3cml0dGVuXG4gICAgdGhpcy5fY2hlY2tMaXN0ZW5lcignbmV3TGlzdGVuZXInLCBzdWJPcHRpb25zLmV2ZW50Lm5hbWUpO1xuICAgIHRoaXMuX2NoZWNrTGlzdGVuZXIoJ3JlbW92ZUxpc3RlbmVyJywgc3ViT3B0aW9ucy5ldmVudC5uYW1lKTtcbiAgICAvLyBUT0RPIGNoZWNrIGlmIGxpc3RlbmVyIGFscmVhZHkgZXhpc3RzPyBhbmQgcmV1c2Ugc3Vic2NyaXB0aW9uIGlmIG9wdGlvbnMgYXJlIHRoZSBzYW1lLlxuICAgIC8vIGNyZWF0ZSBuZXcgc3Vic2NyaXB0aW9uXG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oe1xuICAgICAgICBzdWJzY3JpcHRpb246IHtcbiAgICAgICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dExvZ0Zvcm1hdHRlcl0sXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHRoaXMuX2RlY29kZUV2ZW50QUJJLmJpbmQoc3ViT3B0aW9ucy5ldmVudCksXG4gICAgICAgICAgICAvLyBEVUJMSUNBVEUsIGFsc28gaW4gd2ViMy1ldGhcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbkhhbmRsZXI6IGZ1bmN0aW9uIChvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0LnJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjaGFuZ2VkJywgb3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24odGhpcy5jYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFjayhudWxsLCBvdXRwdXQsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogJ2V0aCcsXG4gICAgICAgIHJlcXVlc3RNYW5hZ2VyOiB0aGlzLl9yZXF1ZXN0TWFuYWdlclxuICAgIH0pO1xuICAgIHN1YnNjcmlwdGlvbi5zdWJzY3JpYmUoJ2xvZ3MnLCBzdWJPcHRpb25zLnBhcmFtcywgc3ViT3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7IH0pO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG59O1xuLyoqXG4gKiBHZXQgcGFzdCBldmVudHMgZnJvbSBjb250cmFjdHNcbiAqXG4gKiBAbWV0aG9kIGdldFBhc3RFdmVudHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBwcm9taWV2ZW50XG4gKi9cbkNvbnRyYWN0LnByb3RvdHlwZS5nZXRQYXN0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdWJPcHRpb25zID0gdGhpcy5fZ2VuZXJhdGVFdmVudE9wdGlvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB2YXIgZ2V0UGFzdExvZ3MgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldFBhc3RMb2dzJyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRMb2dzJyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRMb2dGb3JtYXR0ZXJdLFxuICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHRoaXMuX2RlY29kZUV2ZW50QUJJLmJpbmQoc3ViT3B0aW9ucy5ldmVudClcbiAgICB9KTtcbiAgICBnZXRQYXN0TG9ncy5zZXRSZXF1ZXN0TWFuYWdlcih0aGlzLl9yZXF1ZXN0TWFuYWdlcik7XG4gICAgdmFyIGNhbGwgPSBnZXRQYXN0TG9ncy5idWlsZENhbGwoKTtcbiAgICBnZXRQYXN0TG9ncyA9IG51bGw7XG4gICAgcmV0dXJuIGNhbGwoc3ViT3B0aW9ucy5wYXJhbXMsIHN1Yk9wdGlvbnMuY2FsbGJhY2spO1xufTtcbi8qKlxuICogcmV0dXJucyB0aGUgYW4gb2JqZWN0IHdpdGggY2FsbCwgc2VuZCwgZXN0aW1hdGUgZnVuY3Rpb25zXG4gKlxuICogQG1ldGhvZCBfY3JlYXRlVHhPYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IGFuIG9iamVjdCB3aXRoIGZ1bmN0aW9ucyB0byBjYWxsIHRoZSBtZXRob2RzXG4gKi9cbkNvbnRyYWN0LnByb3RvdHlwZS5fY3JlYXRlVHhPYmplY3QgPSBmdW5jdGlvbiBfY3JlYXRlVHhPYmplY3QoKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciB0eE9iamVjdCA9IHt9O1xuICAgIGlmICh0aGlzLm1ldGhvZC50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHR4T2JqZWN0LmNhbGwgPSB0aGlzLnBhcmVudC5fZXhlY3V0ZU1ldGhvZC5iaW5kKHR4T2JqZWN0LCAnY2FsbCcpO1xuICAgICAgICB0eE9iamVjdC5jYWxsLnJlcXVlc3QgPSB0aGlzLnBhcmVudC5fZXhlY3V0ZU1ldGhvZC5iaW5kKHR4T2JqZWN0LCAnY2FsbCcsIHRydWUpOyAvLyB0byBtYWtlIGJhdGNoIHJlcXVlc3RzXG4gICAgfVxuICAgIHR4T2JqZWN0LnNlbmQgPSB0aGlzLnBhcmVudC5fZXhlY3V0ZU1ldGhvZC5iaW5kKHR4T2JqZWN0LCAnc2VuZCcpO1xuICAgIHR4T2JqZWN0LnNlbmQucmVxdWVzdCA9IHRoaXMucGFyZW50Ll9leGVjdXRlTWV0aG9kLmJpbmQodHhPYmplY3QsICdzZW5kJywgdHJ1ZSk7IC8vIHRvIG1ha2UgYmF0Y2ggcmVxdWVzdHNcbiAgICB0eE9iamVjdC5lbmNvZGVBQkkgPSB0aGlzLnBhcmVudC5fZW5jb2RlTWV0aG9kQUJJLmJpbmQodHhPYmplY3QpO1xuICAgIHR4T2JqZWN0LmVzdGltYXRlR2FzID0gdGhpcy5wYXJlbnQuX2V4ZWN1dGVNZXRob2QuYmluZCh0eE9iamVjdCwgJ2VzdGltYXRlJyk7XG4gICAgaWYgKGFyZ3MgJiYgdGhpcy5tZXRob2QuaW5wdXRzICYmIGFyZ3MubGVuZ3RoICE9PSB0aGlzLm1ldGhvZC5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHRNZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRNZXRob2QuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JzLkludmFsaWROdW1iZXJPZlBhcmFtcyhhcmdzLmxlbmd0aCwgdGhpcy5tZXRob2QuaW5wdXRzLmxlbmd0aCwgdGhpcy5tZXRob2QubmFtZSk7XG4gICAgfVxuICAgIHR4T2JqZWN0LmFyZ3VtZW50cyA9IGFyZ3MgfHwgW107XG4gICAgdHhPYmplY3QuX21ldGhvZCA9IHRoaXMubWV0aG9kO1xuICAgIHR4T2JqZWN0Ll9wYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICB0eE9iamVjdC5fZXRoQWNjb3VudHMgPSB0aGlzLnBhcmVudC5jb25zdHJ1Y3Rvci5fZXRoQWNjb3VudHMgfHwgdGhpcy5fZXRoQWNjb3VudHM7XG4gICAgaWYgKHRoaXMuZGVwbG95RGF0YSkge1xuICAgICAgICB0eE9iamVjdC5fZGVwbG95RGF0YSA9IHRoaXMuZGVwbG95RGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHR4T2JqZWN0O1xufTtcbi8qKlxuICogR2VuZXJhdGVzIHRoZSBvcHRpb25zIGZvciB0aGUgZXhlY3V0ZSBjYWxsXG4gKlxuICogQG1ldGhvZCBfcHJvY2Vzc0V4ZWN1dGVBcmd1bWVudHNcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAqIEBwYXJhbSB7UHJvbWlzZX0gZGVmZXJcbiAqL1xuQ29udHJhY3QucHJvdG90eXBlLl9wcm9jZXNzRXhlY3V0ZUFyZ3VtZW50cyA9IGZ1bmN0aW9uIF9wcm9jZXNzRXhlY3V0ZUFyZ3VtZW50cyhhcmdzLCBkZWZlcikge1xuICAgIHZhciBwcm9jZXNzZWRBcmdzID0ge307XG4gICAgcHJvY2Vzc2VkQXJncy50eXBlID0gYXJncy5zaGlmdCgpO1xuICAgIC8vIGdldCB0aGUgY2FsbGJhY2tcbiAgICBwcm9jZXNzZWRBcmdzLmNhbGxiYWNrID0gdGhpcy5fcGFyZW50Ll9nZXRDYWxsYmFjayhhcmdzKTtcbiAgICAvLyBnZXQgYmxvY2sgbnVtYmVyIHRvIHVzZSBmb3IgY2FsbFxuICAgIGlmIChwcm9jZXNzZWRBcmdzLnR5cGUgPT09ICdjYWxsJyAmJiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gIT09IHRydWUgJiYgKF8uaXNTdHJpbmcoYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB8fCBpc0Zpbml0ZShhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pKSlcbiAgICAgICAgcHJvY2Vzc2VkQXJncy5kZWZhdWx0QmxvY2sgPSBhcmdzLnBvcCgpO1xuICAgIC8vIGdldCB0aGUgb3B0aW9uc1xuICAgIHByb2Nlc3NlZEFyZ3Mub3B0aW9ucyA9IChfLmlzT2JqZWN0KGFyZ3NbYXJncy5sZW5ndGggLSAxXSkpID8gYXJncy5wb3AoKSA6IHt9O1xuICAgIC8vIGdldCB0aGUgZ2VuZXJhdGVSZXF1ZXN0IGFyZ3VtZW50IGZvciBiYXRjaCByZXF1ZXN0c1xuICAgIHByb2Nlc3NlZEFyZ3MuZ2VuZXJhdGVSZXF1ZXN0ID0gKGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gdHJ1ZSkgPyBhcmdzLnBvcCgpIDogZmFsc2U7XG4gICAgcHJvY2Vzc2VkQXJncy5vcHRpb25zID0gdGhpcy5fcGFyZW50Ll9nZXRPclNldERlZmF1bHRPcHRpb25zKHByb2Nlc3NlZEFyZ3Mub3B0aW9ucyk7XG4gICAgcHJvY2Vzc2VkQXJncy5vcHRpb25zLmRhdGEgPSB0aGlzLmVuY29kZUFCSSgpO1xuICAgIC8vIGFkZCBjb250cmFjdCBhZGRyZXNzXG4gICAgaWYgKCF0aGlzLl9kZXBsb3lEYXRhICYmICF1dGlscy5pc0FkZHJlc3ModGhpcy5fcGFyZW50Lm9wdGlvbnMuYWRkcmVzcykpXG4gICAgICAgIHRocm93IGVycm9ycy5Db250cmFjdE5vQWRkcmVzc0RlZmluZWRFcnJvcigpO1xuICAgIGlmICghdGhpcy5fZGVwbG95RGF0YSlcbiAgICAgICAgcHJvY2Vzc2VkQXJncy5vcHRpb25zLnRvID0gdGhpcy5fcGFyZW50Lm9wdGlvbnMuYWRkcmVzcztcbiAgICAvLyByZXR1cm4gZXJyb3IsIGlmIG5vIFwiZGF0YVwiIGlzIHNwZWNpZmllZFxuICAgIGlmICghcHJvY2Vzc2VkQXJncy5vcHRpb25zLmRhdGEpXG4gICAgICAgIHJldHVybiB1dGlscy5fZmlyZUVycm9yKG5ldyBFcnJvcignQ291bGRuXFwndCBmaW5kIGEgbWF0Y2hpbmcgY29udHJhY3QgbWV0aG9kLCBvciB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMgaXMgd3JvbmcuJyksIGRlZmVyLmV2ZW50RW1pdHRlciwgZGVmZXIucmVqZWN0LCBwcm9jZXNzZWRBcmdzLmNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvY2Vzc2VkQXJncztcbn07XG4vKipcbiAqIEV4ZWN1dGVzIGEgY2FsbCwgdHJhbnNhY3Qgb3IgZXN0aW1hdGVHYXMgb24gYSBjb250cmFjdCBmdW5jdGlvblxuICpcbiAqIEBtZXRob2QgX2V4ZWN1dGVNZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIHRoaXMgZXhlY3V0ZSBmdW5jdGlvbiBzaG91bGQgZXhlY3V0ZVxuICogQHBhcmFtIHtCb29sZWFufSBtYWtlUmVxdWVzdCBpZiB0cnVlLCBpdCBzaW1wbHkgcmV0dXJucyB0aGUgcmVxdWVzdCBwYXJhbWV0ZXJzLCByYXRoZXIgdGhhbiBleGVjdXRpbmcgaXRcbiAqL1xuQ29udHJhY3QucHJvdG90eXBlLl9leGVjdXRlTWV0aG9kID0gZnVuY3Rpb24gX2V4ZWN1dGVNZXRob2QoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcywgYXJncyA9IHRoaXMuX3BhcmVudC5fcHJvY2Vzc0V4ZWN1dGVBcmd1bWVudHMuY2FsbCh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLCBkZWZlciksIGRlZmVyID0gcHJvbWlFdmVudCgoYXJncy50eXBlICE9PSAnc2VuZCcpKSwgZXRoQWNjb3VudHMgPSBfdGhpcy5jb25zdHJ1Y3Rvci5fZXRoQWNjb3VudHMgfHwgX3RoaXMuX2V0aEFjY291bnRzO1xuICAgIC8vIHNpbXBsZSByZXR1cm4gcmVxdWVzdCBmb3IgYmF0Y2ggcmVxdWVzdHNcbiAgICBpZiAoYXJncy5nZW5lcmF0ZVJlcXVlc3QpIHtcbiAgICAgICAgdmFyIHBheWxvYWQgPSB7XG4gICAgICAgICAgICBwYXJhbXM6IFtmb3JtYXR0ZXJzLmlucHV0Q2FsbEZvcm1hdHRlci5jYWxsKHRoaXMuX3BhcmVudCwgYXJncy5vcHRpb25zKV0sXG4gICAgICAgICAgICBjYWxsYmFjazogYXJncy5jYWxsYmFja1xuICAgICAgICB9O1xuICAgICAgICBpZiAoYXJncy50eXBlID09PSAnY2FsbCcpIHtcbiAgICAgICAgICAgIHBheWxvYWQucGFyYW1zLnB1c2goZm9ybWF0dGVycy5pbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlci5jYWxsKHRoaXMuX3BhcmVudCwgYXJncy5kZWZhdWx0QmxvY2spKTtcbiAgICAgICAgICAgIHBheWxvYWQubWV0aG9kID0gJ2V0aF9jYWxsJztcbiAgICAgICAgICAgIHBheWxvYWQuZm9ybWF0ID0gdGhpcy5fcGFyZW50Ll9kZWNvZGVNZXRob2RSZXR1cm4uYmluZChudWxsLCB0aGlzLl9tZXRob2Qub3V0cHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXlsb2FkLm1ldGhvZCA9ICdldGhfc2VuZFRyYW5zYWN0aW9uJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9XG4gICAgc3dpdGNoIChhcmdzLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnZXN0aW1hdGUnOlxuICAgICAgICAgICAgdmFyIGVzdGltYXRlR2FzID0gKG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdlc3RpbWF0ZUdhcycsXG4gICAgICAgICAgICAgICAgY2FsbDogJ2V0aF9lc3RpbWF0ZUdhcycsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dENhbGxGb3JtYXR0ZXJdLFxuICAgICAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogdXRpbHMuaGV4VG9OdW1iZXIsXG4gICAgICAgICAgICAgICAgcmVxdWVzdE1hbmFnZXI6IF90aGlzLl9wYXJlbnQuX3JlcXVlc3RNYW5hZ2VyLFxuICAgICAgICAgICAgICAgIGFjY291bnRzOiBldGhBY2NvdW50cyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0QWNjb3VudDogX3RoaXMuX3BhcmVudC5kZWZhdWx0QWNjb3VudCxcbiAgICAgICAgICAgICAgICBkZWZhdWx0QmxvY2s6IF90aGlzLl9wYXJlbnQuZGVmYXVsdEJsb2NrXG4gICAgICAgICAgICB9KSkuY3JlYXRlRnVuY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBlc3RpbWF0ZUdhcyhhcmdzLm9wdGlvbnMsIGFyZ3MuY2FsbGJhY2spO1xuICAgICAgICBjYXNlICdjYWxsJzpcbiAgICAgICAgICAgIC8vIFRPRE8gY2hlY2sgZXJyb3JzOiBtaXNzaW5nIFwiZnJvbVwiIHNob3VsZCBnaXZlIGVycm9yIG9uIGRlcGxveSBhbmQgc2VuZCwgY2FsbCA/XG4gICAgICAgICAgICB2YXIgY2FsbCA9IChuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2FsbCcsXG4gICAgICAgICAgICAgICAgY2FsbDogJ2V0aF9jYWxsJyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0Q2FsbEZvcm1hdHRlciwgZm9ybWF0dGVycy5pbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcl0sXG4gICAgICAgICAgICAgICAgLy8gYWRkIG91dHB1dCBmb3JtYXR0ZXIgZm9yIGRlY29kaW5nXG4gICAgICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcGFyZW50Ll9kZWNvZGVNZXRob2RSZXR1cm4oX3RoaXMuX21ldGhvZC5vdXRwdXRzLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVxdWVzdE1hbmFnZXI6IF90aGlzLl9wYXJlbnQuX3JlcXVlc3RNYW5hZ2VyLFxuICAgICAgICAgICAgICAgIGFjY291bnRzOiBldGhBY2NvdW50cyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0QWNjb3VudDogX3RoaXMuX3BhcmVudC5kZWZhdWx0QWNjb3VudCxcbiAgICAgICAgICAgICAgICBkZWZhdWx0QmxvY2s6IF90aGlzLl9wYXJlbnQuZGVmYXVsdEJsb2NrLFxuICAgICAgICAgICAgICAgIGhhbmRsZVJldmVydDogX3RoaXMuX3BhcmVudC5oYW5kbGVSZXZlcnQsXG4gICAgICAgICAgICAgICAgYWJpQ29kZXI6IGFiaVxuICAgICAgICAgICAgfSkpLmNyZWF0ZUZ1bmN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbChhcmdzLm9wdGlvbnMsIGFyZ3MuZGVmYXVsdEJsb2NrLCBhcmdzLmNhbGxiYWNrKTtcbiAgICAgICAgY2FzZSAnc2VuZCc6XG4gICAgICAgICAgICAvLyByZXR1cm4gZXJyb3IsIGlmIG5vIFwiZnJvbVwiIGlzIHNwZWNpZmllZFxuICAgICAgICAgICAgaWYgKCF1dGlscy5pc0FkZHJlc3MoYXJncy5vcHRpb25zLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLl9maXJlRXJyb3IoZXJyb3JzLkNvbnRyYWN0Tm9Gcm9tQWRkcmVzc0RlZmluZWRFcnJvcigpLCBkZWZlci5ldmVudEVtaXR0ZXIsIGRlZmVyLnJlamVjdCwgYXJncy5jYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXy5pc0Jvb2xlYW4odGhpcy5fbWV0aG9kLnBheWFibGUpICYmICF0aGlzLl9tZXRob2QucGF5YWJsZSAmJiBhcmdzLm9wdGlvbnMudmFsdWUgJiYgYXJncy5vcHRpb25zLnZhbHVlID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlscy5fZmlyZUVycm9yKG5ldyBFcnJvcignQ2FuIG5vdCBzZW5kIHZhbHVlIHRvIG5vbi1wYXlhYmxlIGNvbnRyYWN0IG1ldGhvZCBvciBjb25zdHJ1Y3RvcicpLCBkZWZlci5ldmVudEVtaXR0ZXIsIGRlZmVyLnJlamVjdCwgYXJncy5jYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgcmVjZWlwdCBsb2dzIGFyZSBkZWNvZGVkXG4gICAgICAgICAgICB2YXIgZXh0cmFGb3JtYXR0ZXJzID0ge1xuICAgICAgICAgICAgICAgIHJlY2VpcHRGb3JtYXR0ZXI6IGZ1bmN0aW9uIChyZWNlaXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkocmVjZWlwdC5sb2dzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVjb2RlIGxvZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldmVudHMgPSBfLm1hcChyZWNlaXB0LmxvZ3MsIGZ1bmN0aW9uIChsb2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3BhcmVudC5fZGVjb2RlRXZlbnRBQkkuY2FsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBTExFVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uSW50ZXJmYWNlOiBfdGhpcy5fcGFyZW50Lm9wdGlvbnMuanNvbkludGVyZmFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGxvZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgbG9nIG5hbWVzIGtleXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHQuZXZlbnRzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2LmV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmID4gMSBvZiB0aGUgc2FtZSBldmVudCwgZG9uJ3Qgb3ZlcndyaXRlIGFueSBleGlzdGluZyBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQuZXZlbnRzW2V2LmV2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVjZWlwdC5ldmVudHNbZXYuZXZlbnRdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHQuZXZlbnRzW2V2LmV2ZW50XS5wdXNoKGV2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHQuZXZlbnRzW2V2LmV2ZW50XSA9IFtyZWNlaXB0LmV2ZW50c1tldi5ldmVudF0sIGV2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHQuZXZlbnRzW2V2LmV2ZW50XSA9IGV2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0LmV2ZW50c1tjb3VudF0gPSBldjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZWNlaXB0LmxvZ3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb250cmFjdERlcGxveUZvcm1hdHRlcjogZnVuY3Rpb24gKHJlY2VpcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0NvbnRyYWN0ID0gX3RoaXMuX3BhcmVudC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250cmFjdC5vcHRpb25zLmFkZHJlc3MgPSByZWNlaXB0LmNvbnRyYWN0QWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NvbnRyYWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgc2VuZFRyYW5zYWN0aW9uID0gKG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdzZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIGNhbGw6ICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXJdLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RNYW5hZ2VyOiBfdGhpcy5fcGFyZW50Ll9yZXF1ZXN0TWFuYWdlcixcbiAgICAgICAgICAgICAgICBhY2NvdW50czogX3RoaXMuY29uc3RydWN0b3IuX2V0aEFjY291bnRzIHx8IF90aGlzLl9ldGhBY2NvdW50cyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0QWNjb3VudDogX3RoaXMuX3BhcmVudC5kZWZhdWx0QWNjb3VudCxcbiAgICAgICAgICAgICAgICBkZWZhdWx0QmxvY2s6IF90aGlzLl9wYXJlbnQuZGVmYXVsdEJsb2NrLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uQmxvY2tUaW1lb3V0OiBfdGhpcy5fcGFyZW50LnRyYW5zYWN0aW9uQmxvY2tUaW1lb3V0LFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uQ29uZmlybWF0aW9uQmxvY2tzOiBfdGhpcy5fcGFyZW50LnRyYW5zYWN0aW9uQ29uZmlybWF0aW9uQmxvY2tzLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uUG9sbGluZ1RpbWVvdXQ6IF90aGlzLl9wYXJlbnQudHJhbnNhY3Rpb25Qb2xsaW5nVGltZW91dCxcbiAgICAgICAgICAgICAgICBkZWZhdWx0Q29tbW9uOiBfdGhpcy5fcGFyZW50LmRlZmF1bHRDb21tb24sXG4gICAgICAgICAgICAgICAgZGVmYXVsdENoYWluOiBfdGhpcy5fcGFyZW50LmRlZmF1bHRDaGFpbixcbiAgICAgICAgICAgICAgICBkZWZhdWx0SGFyZGZvcms6IF90aGlzLl9wYXJlbnQuZGVmYXVsdEhhcmRmb3JrLFxuICAgICAgICAgICAgICAgIGhhbmRsZVJldmVydDogX3RoaXMuX3BhcmVudC5oYW5kbGVSZXZlcnQsXG4gICAgICAgICAgICAgICAgZXh0cmFGb3JtYXR0ZXJzOiBleHRyYUZvcm1hdHRlcnMsXG4gICAgICAgICAgICAgICAgYWJpQ29kZXI6IGFiaVxuICAgICAgICAgICAgfSkpLmNyZWF0ZUZ1bmN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gc2VuZFRyYW5zYWN0aW9uKGFyZ3Mub3B0aW9ucywgYXJncy5jYWxsYmFjayk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBcIicgKyBhcmdzLnR5cGUgKyAnXCIgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IENvbnRyYWN0O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/web3-eth-contract/lib/index.js\n");

/***/ })

}]);