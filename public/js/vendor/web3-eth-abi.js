/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendor/web3-eth-abi"],{

/***/ "./node_modules/web3-eth-abi/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/web3-eth-abi/lib/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file index.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2018\n */\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer;\nvar _ = __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore.js\");\nvar utils = __webpack_require__(/*! web3-utils */ \"./node_modules/web3-utils/lib/index.js\");\nvar EthersAbiCoder = __webpack_require__(/*! @ethersproject/abi */ \"./node_modules/@ethersproject/abi/lib.esm/index.js\").AbiCoder;\nvar ParamType = __webpack_require__(/*! @ethersproject/abi */ \"./node_modules/@ethersproject/abi/lib.esm/index.js\").ParamType;\nvar ethersAbiCoder = new EthersAbiCoder(function (type, value) {\n    if (type.match(/^u?int/) && !_.isArray(value) && (!_.isObject(value) || value.constructor.name !== 'BN')) {\n        return value.toString();\n    }\n    return value;\n});\n// result method\nfunction Result() {\n}\n/**\n * ABICoder prototype should be used to encode/decode solidity params of any type\n */\nvar ABICoder = function () {\n};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeFunctionSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeFunctionSignature = function (functionName) {\n    if (_.isObject(functionName)) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n    return utils.sha3(functionName).slice(0, 10);\n};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeEventSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeEventSignature = function (functionName) {\n    if (_.isObject(functionName)) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n    return utils.sha3(functionName);\n};\n/**\n * Should be used to encode plain param\n *\n * @method encodeParameter\n *\n * @param {String|Object} type\n * @param {any} param\n *\n * @return {String} encoded plain param\n */\nABICoder.prototype.encodeParameter = function (type, param) {\n    return this.encodeParameters([type], [param]);\n};\n/**\n * Should be used to encode list of params\n *\n * @method encodeParameters\n *\n * @param {Array<String|Object>} types\n * @param {Array<any>} params\n *\n * @return {String} encoded list of params\n */\nABICoder.prototype.encodeParameters = function (types, params) {\n    var self = this;\n    types = self.mapTypes(types);\n    params = params.map(function (param, index) {\n        let type = types[index];\n        if (typeof type === 'object' && type.type) {\n            // We may get a named type of shape {name, type}\n            type = type.type;\n        }\n        param = self.formatParam(type, param);\n        // Format params for tuples\n        if (typeof type === 'string' && type.includes('tuple')) {\n            const coder = ethersAbiCoder._getCoder(ParamType.from(type));\n            const modifyParams = (coder, param) => {\n                if (coder.name === 'array') {\n                    return param.map(p => modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace('[]', ''))), p));\n                }\n                coder.coders.forEach((c, i) => {\n                    if (c.name === 'tuple') {\n                        modifyParams(c, param[i]);\n                    }\n                    else {\n                        param[i] = self.formatParam(c.name, param[i]);\n                    }\n                });\n            };\n            modifyParams(coder, param);\n        }\n        return param;\n    });\n    return ethersAbiCoder.encode(types, params);\n};\n/**\n * Map types if simplified format is used\n *\n * @method mapTypes\n * @param {Array} types\n * @return {Array}\n */\nABICoder.prototype.mapTypes = function (types) {\n    var self = this;\n    var mappedTypes = [];\n    types.forEach(function (type) {\n        // Remap `function` type params to bytes24 since Ethers does not\n        // recognize former type. Solidity docs say `Function` is a bytes24\n        // encoding the contract address followed by the function selector hash.\n        if (typeof type === 'object' && type.type === 'function') {\n            type = Object.assign({}, type, { type: \"bytes24\" });\n        }\n        if (self.isSimplifiedStructFormat(type)) {\n            var structName = Object.keys(type)[0];\n            mappedTypes.push(Object.assign(self.mapStructNameAndType(structName), {\n                components: self.mapStructToCoderFormat(type[structName])\n            }));\n            return;\n        }\n        mappedTypes.push(type);\n    });\n    return mappedTypes;\n};\n/**\n * Check if type is simplified struct format\n *\n * @method isSimplifiedStructFormat\n * @param {string | Object} type\n * @returns {boolean}\n */\nABICoder.prototype.isSimplifiedStructFormat = function (type) {\n    return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n};\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n *\n * @method mapStructNameAndType\n * @param {string} structName\n * @return {{type: string, name: *}}\n */\nABICoder.prototype.mapStructNameAndType = function (structName) {\n    var type = 'tuple';\n    if (structName.indexOf('[]') > -1) {\n        type = 'tuple[]';\n        structName = structName.slice(0, -2);\n    }\n    return { type: type, name: structName };\n};\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n *\n * @method mapStructToCoderFormat\n * @param {Object} struct\n * @return {Array}\n */\nABICoder.prototype.mapStructToCoderFormat = function (struct) {\n    var self = this;\n    var components = [];\n    Object.keys(struct).forEach(function (key) {\n        if (typeof struct[key] === 'object') {\n            components.push(Object.assign(self.mapStructNameAndType(key), {\n                components: self.mapStructToCoderFormat(struct[key])\n            }));\n            return;\n        }\n        components.push({\n            name: key,\n            type: struct[key]\n        });\n    });\n    return components;\n};\n/**\n * Handle some formatting of params for backwards compatability with Ethers V4\n *\n * @method formatParam\n * @param {String} - type\n * @param {any} - param\n * @return {any} - The formatted param\n */\nABICoder.prototype.formatParam = function (type, param) {\n    const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n    const paramTypeBytesArray = new RegExp(/^bytes([0-9]*)\\[\\]$/);\n    const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n    const paramTypeNumberArray = new RegExp(/^(u?int)([0-9]*)\\[\\]$/);\n    // Format BN to string\n    if (utils.isBN(param) || utils.isBigNumber(param)) {\n        return param.toString(10);\n    }\n    if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {\n        return param.map(p => this.formatParam(type.replace('[]', ''), p));\n    }\n    // Format correct width for u?int[0-9]*\n    let match = type.match(paramTypeNumber);\n    if (match) {\n        let size = parseInt(match[2] || \"256\");\n        if (size / 8 < param.length) {\n            // pad to correct bit width\n            param = utils.leftPad(param, size);\n        }\n    }\n    // Format correct length for bytes[0-9]+\n    match = type.match(paramTypeBytes);\n    if (match) {\n        if (Buffer.isBuffer(param)) {\n            param = utils.toHex(param);\n        }\n        // format to correct length\n        let size = parseInt(match[1]);\n        if (size) {\n            let maxSize = size * 2;\n            if (param.substring(0, 2) === '0x') {\n                maxSize += 2;\n            }\n            if (param.length < maxSize) {\n                // pad to correct length\n                param = utils.rightPad(param, size * 2);\n            }\n        }\n        // format odd-length bytes to even-length\n        if (param.length % 2 === 1) {\n            param = '0x0' + param.substring(2);\n        }\n    }\n    return param;\n};\n/**\n * Encodes a function call from its json interface and parameters.\n *\n * @method encodeFunctionCall\n * @param {Array} jsonInterface\n * @param {Array} params\n * @return {String} The encoded ABI for this function call\n */\nABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {\n    return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\n};\n/**\n * Should be used to decode bytes to plain param\n *\n * @method decodeParameter\n * @param {String} type\n * @param {String} bytes\n * @return {Object} plain param\n */\nABICoder.prototype.decodeParameter = function (type, bytes) {\n    return this.decodeParameters([type], bytes)[0];\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParameters = function (outputs, bytes) {\n    return this.decodeParametersWith(outputs, bytes, false);\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @param {Boolean} loose\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParametersWith = function (outputs, bytes, loose) {\n    if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n        throw new Error('Returned values aren\\'t valid, did it run Out of Gas? ' +\n            'You might also see this error if you are not using the ' +\n            'correct ABI for the contract you are retrieving data from, ' +\n            'requesting data from a block number that does not exist, ' +\n            'or querying a node which is not fully synced.');\n    }\n    var res = ethersAbiCoder.decode(this.mapTypes(outputs), '0x' + bytes.replace(/0x/i, ''), loose);\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n    outputs.forEach(function (output, i) {\n        var decodedValue = res[returnValue.__length__];\n        decodedValue = (decodedValue === '0x') ? null : decodedValue;\n        returnValue[i] = decodedValue;\n        if (_.isObject(output) && output.name) {\n            returnValue[output.name] = decodedValue;\n        }\n        returnValue.__length__++;\n    });\n    return returnValue;\n};\n/**\n * Decodes events non- and indexed parameters.\n *\n * @method decodeLog\n * @param {Object} inputs\n * @param {String} data\n * @param {Array} topics\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeLog = function (inputs, data, topics) {\n    var _this = this;\n    topics = _.isArray(topics) ? topics : [topics];\n    data = data || '';\n    var notIndexedInputs = [];\n    var indexedParams = [];\n    var topicCount = 0;\n    // TODO check for anonymous logs?\n    inputs.forEach(function (input, i) {\n        if (input.indexed) {\n            indexedParams[i] = (['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\n                return input.type.indexOf(staticType) !== -1;\n            })) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n            topicCount++;\n        }\n        else {\n            notIndexedInputs[i] = input;\n        }\n    });\n    var nonIndexedData = data;\n    var notIndexedParams = (nonIndexedData) ? this.decodeParametersWith(notIndexedInputs, nonIndexedData, true) : [];\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n    inputs.forEach(function (res, i) {\n        returnValue[i] = (res.type === 'string') ? '' : null;\n        if (typeof notIndexedParams[i] !== 'undefined') {\n            returnValue[i] = notIndexedParams[i];\n        }\n        if (typeof indexedParams[i] !== 'undefined') {\n            returnValue[i] = indexedParams[i];\n        }\n        if (res.name) {\n            returnValue[res.name] = returnValue[i];\n        }\n        returnValue.__length__++;\n    });\n    return returnValue;\n};\nvar coder = new ABICoder();\nmodule.exports = coder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2ViMy1ldGgtYWJpL2xpYi9pbmRleC5qcz9hYWIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBFQUF3QjtBQUNyQyxRQUFRLG1CQUFPLENBQUMsMkRBQVk7QUFDNUIsWUFBWSxtQkFBTyxDQUFDLDBEQUFZO0FBQ2hDLHFCQUFxQiw0R0FBc0M7QUFDM0QsZ0JBQWdCLDZHQUF1QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsSUFBSTtBQUNmO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsV0FBVztBQUN0QjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVMsa0JBQWtCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLElBQUk7QUFDZixZQUFZLElBQUk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2ViMy1ldGgtYWJpL2xpYi9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiAqL1xuLyoqXG4gKiBAZmlsZSBpbmRleC5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAcGFyaXR5LmlvPlxuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZnJvemVtYW4uZGU+XG4gKiBAZGF0ZSAyMDE4XG4gKi9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ3dlYjMtdXRpbHMnKTtcbnZhciBFdGhlcnNBYmlDb2RlciA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2FiaScpLkFiaUNvZGVyO1xudmFyIFBhcmFtVHlwZSA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2FiaScpLlBhcmFtVHlwZTtcbnZhciBldGhlcnNBYmlDb2RlciA9IG5ldyBFdGhlcnNBYmlDb2RlcihmdW5jdGlvbiAodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZS5tYXRjaCgvXnU/aW50LykgJiYgIV8uaXNBcnJheSh2YWx1ZSkgJiYgKCFfLmlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnQk4nKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufSk7XG4vLyByZXN1bHQgbWV0aG9kXG5mdW5jdGlvbiBSZXN1bHQoKSB7XG59XG4vKipcbiAqIEFCSUNvZGVyIHByb3RvdHlwZSBzaG91bGQgYmUgdXNlZCB0byBlbmNvZGUvZGVjb2RlIHNvbGlkaXR5IHBhcmFtcyBvZiBhbnkgdHlwZVxuICovXG52YXIgQUJJQ29kZXIgPSBmdW5jdGlvbiAoKSB7XG59O1xuLyoqXG4gKiBFbmNvZGVzIHRoZSBmdW5jdGlvbiBuYW1lIHRvIGl0cyBBQkkgcmVwcmVzZW50YXRpb24sIHdoaWNoIGFyZSB0aGUgZmlyc3QgNCBieXRlcyBvZiB0aGUgc2hhMyBvZiB0aGUgZnVuY3Rpb24gbmFtZSBpbmNsdWRpbmcgIHR5cGVzLlxuICpcbiAqIEBtZXRob2QgZW5jb2RlRnVuY3Rpb25TaWduYXR1cmVcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZnVuY3Rpb25OYW1lXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWQgZnVuY3Rpb24gbmFtZVxuICovXG5BQklDb2Rlci5wcm90b3R5cGUuZW5jb2RlRnVuY3Rpb25TaWduYXR1cmUgPSBmdW5jdGlvbiAoZnVuY3Rpb25OYW1lKSB7XG4gICAgaWYgKF8uaXNPYmplY3QoZnVuY3Rpb25OYW1lKSkge1xuICAgICAgICBmdW5jdGlvbk5hbWUgPSB1dGlscy5fanNvbkludGVyZmFjZU1ldGhvZFRvU3RyaW5nKGZ1bmN0aW9uTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB1dGlscy5zaGEzKGZ1bmN0aW9uTmFtZSkuc2xpY2UoMCwgMTApO1xufTtcbi8qKlxuICogRW5jb2RlcyB0aGUgZnVuY3Rpb24gbmFtZSB0byBpdHMgQUJJIHJlcHJlc2VudGF0aW9uLCB3aGljaCBhcmUgdGhlIGZpcnN0IDQgYnl0ZXMgb2YgdGhlIHNoYTMgb2YgdGhlIGZ1bmN0aW9uIG5hbWUgaW5jbHVkaW5nICB0eXBlcy5cbiAqXG4gKiBAbWV0aG9kIGVuY29kZUV2ZW50U2lnbmF0dXJlXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGZ1bmN0aW9uTmFtZVxuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkIGZ1bmN0aW9uIG5hbWVcbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLmVuY29kZUV2ZW50U2lnbmF0dXJlID0gZnVuY3Rpb24gKGZ1bmN0aW9uTmFtZSkge1xuICAgIGlmIChfLmlzT2JqZWN0KGZ1bmN0aW9uTmFtZSkpIHtcbiAgICAgICAgZnVuY3Rpb25OYW1lID0gdXRpbHMuX2pzb25JbnRlcmZhY2VNZXRob2RUb1N0cmluZyhmdW5jdGlvbk5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMuc2hhMyhmdW5jdGlvbk5hbWUpO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZW5jb2RlIHBsYWluIHBhcmFtXG4gKlxuICogQG1ldGhvZCBlbmNvZGVQYXJhbWV0ZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHR5cGVcbiAqIEBwYXJhbSB7YW55fSBwYXJhbVxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZCBwbGFpbiBwYXJhbVxuICovXG5BQklDb2Rlci5wcm90b3R5cGUuZW5jb2RlUGFyYW1ldGVyID0gZnVuY3Rpb24gKHR5cGUsIHBhcmFtKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RlUGFyYW1ldGVycyhbdHlwZV0sIFtwYXJhbV0pO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZW5jb2RlIGxpc3Qgb2YgcGFyYW1zXG4gKlxuICogQG1ldGhvZCBlbmNvZGVQYXJhbWV0ZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheTxTdHJpbmd8T2JqZWN0Pn0gdHlwZXNcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gcGFyYW1zXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkIGxpc3Qgb2YgcGFyYW1zXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5lbmNvZGVQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHR5cGVzLCBwYXJhbXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdHlwZXMgPSBzZWxmLm1hcFR5cGVzKHR5cGVzKTtcbiAgICBwYXJhbXMgPSBwYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpbmRleF07XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZS50eXBlKSB7XG4gICAgICAgICAgICAvLyBXZSBtYXkgZ2V0IGEgbmFtZWQgdHlwZSBvZiBzaGFwZSB7bmFtZSwgdHlwZX1cbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW0gPSBzZWxmLmZvcm1hdFBhcmFtKHR5cGUsIHBhcmFtKTtcbiAgICAgICAgLy8gRm9ybWF0IHBhcmFtcyBmb3IgdHVwbGVzXG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgJiYgdHlwZS5pbmNsdWRlcygndHVwbGUnKSkge1xuICAgICAgICAgICAgY29uc3QgY29kZXIgPSBldGhlcnNBYmlDb2Rlci5fZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpO1xuICAgICAgICAgICAgY29uc3QgbW9kaWZ5UGFyYW1zID0gKGNvZGVyLCBwYXJhbSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb2Rlci5uYW1lID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbS5tYXAocCA9PiBtb2RpZnlQYXJhbXMoZXRoZXJzQWJpQ29kZXIuX2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKGNvZGVyLnR5cGUucmVwbGFjZSgnW10nLCAnJykpKSwgcCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2Rlci5jb2RlcnMuZm9yRWFjaCgoYywgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYy5uYW1lID09PSAndHVwbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZnlQYXJhbXMoYywgcGFyYW1baV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1baV0gPSBzZWxmLmZvcm1hdFBhcmFtKGMubmFtZSwgcGFyYW1baV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbW9kaWZ5UGFyYW1zKGNvZGVyLCBwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgIH0pO1xuICAgIHJldHVybiBldGhlcnNBYmlDb2Rlci5lbmNvZGUodHlwZXMsIHBhcmFtcyk7XG59O1xuLyoqXG4gKiBNYXAgdHlwZXMgaWYgc2ltcGxpZmllZCBmb3JtYXQgaXMgdXNlZFxuICpcbiAqIEBtZXRob2QgbWFwVHlwZXNcbiAqIEBwYXJhbSB7QXJyYXl9IHR5cGVzXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLm1hcFR5cGVzID0gZnVuY3Rpb24gKHR5cGVzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBtYXBwZWRUeXBlcyA9IFtdO1xuICAgIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgLy8gUmVtYXAgYGZ1bmN0aW9uYCB0eXBlIHBhcmFtcyB0byBieXRlczI0IHNpbmNlIEV0aGVycyBkb2VzIG5vdFxuICAgICAgICAvLyByZWNvZ25pemUgZm9ybWVyIHR5cGUuIFNvbGlkaXR5IGRvY3Mgc2F5IGBGdW5jdGlvbmAgaXMgYSBieXRlczI0XG4gICAgICAgIC8vIGVuY29kaW5nIHRoZSBjb250cmFjdCBhZGRyZXNzIGZvbGxvd2VkIGJ5IHRoZSBmdW5jdGlvbiBzZWxlY3RvciBoYXNoLlxuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdHlwZSA9IE9iamVjdC5hc3NpZ24oe30sIHR5cGUsIHsgdHlwZTogXCJieXRlczI0XCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuaXNTaW1wbGlmaWVkU3RydWN0Rm9ybWF0KHR5cGUpKSB7XG4gICAgICAgICAgICB2YXIgc3RydWN0TmFtZSA9IE9iamVjdC5rZXlzKHR5cGUpWzBdO1xuICAgICAgICAgICAgbWFwcGVkVHlwZXMucHVzaChPYmplY3QuYXNzaWduKHNlbGYubWFwU3RydWN0TmFtZUFuZFR5cGUoc3RydWN0TmFtZSksIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBzZWxmLm1hcFN0cnVjdFRvQ29kZXJGb3JtYXQodHlwZVtzdHJ1Y3ROYW1lXSlcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtYXBwZWRUeXBlcy5wdXNoKHR5cGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXBwZWRUeXBlcztcbn07XG4vKipcbiAqIENoZWNrIGlmIHR5cGUgaXMgc2ltcGxpZmllZCBzdHJ1Y3QgZm9ybWF0XG4gKlxuICogQG1ldGhvZCBpc1NpbXBsaWZpZWRTdHJ1Y3RGb3JtYXRcbiAqIEBwYXJhbSB7c3RyaW5nIHwgT2JqZWN0fSB0eXBlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLmlzU2ltcGxpZmllZFN0cnVjdEZvcm1hdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdHlwZS5jb21wb25lbnRzID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdHlwZS5uYW1lID09PSAndW5kZWZpbmVkJztcbn07XG4vKipcbiAqIE1hcHMgdGhlIGNvcnJlY3QgdHVwbGUgdHlwZSBhbmQgbmFtZSB3aGVuIHRoZSBzaW1wbGlmaWVkIGZvcm1hdCBpbiBlbmNvZGUvZGVjb2RlUGFyYW1ldGVyIGlzIHVzZWRcbiAqXG4gKiBAbWV0aG9kIG1hcFN0cnVjdE5hbWVBbmRUeXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RydWN0TmFtZVxuICogQHJldHVybiB7e3R5cGU6IHN0cmluZywgbmFtZTogKn19XG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5tYXBTdHJ1Y3ROYW1lQW5kVHlwZSA9IGZ1bmN0aW9uIChzdHJ1Y3ROYW1lKSB7XG4gICAgdmFyIHR5cGUgPSAndHVwbGUnO1xuICAgIGlmIChzdHJ1Y3ROYW1lLmluZGV4T2YoJ1tdJykgPiAtMSkge1xuICAgICAgICB0eXBlID0gJ3R1cGxlW10nO1xuICAgICAgICBzdHJ1Y3ROYW1lID0gc3RydWN0TmFtZS5zbGljZSgwLCAtMik7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIG5hbWU6IHN0cnVjdE5hbWUgfTtcbn07XG4vKipcbiAqIE1hcHMgdGhlIHNpbXBsaWZpZWQgZm9ybWF0IGluIHRvIHRoZSBleHBlY3RlZCBmb3JtYXQgb2YgdGhlIEFCSUNvZGVyXG4gKlxuICogQG1ldGhvZCBtYXBTdHJ1Y3RUb0NvZGVyRm9ybWF0XG4gKiBAcGFyYW0ge09iamVjdH0gc3RydWN0XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLm1hcFN0cnVjdFRvQ29kZXJGb3JtYXQgPSBmdW5jdGlvbiAoc3RydWN0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgT2JqZWN0LmtleXMoc3RydWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJ1Y3Rba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChPYmplY3QuYXNzaWduKHNlbGYubWFwU3RydWN0TmFtZUFuZFR5cGUoa2V5KSwge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IHNlbGYubWFwU3RydWN0VG9Db2RlckZvcm1hdChzdHJ1Y3Rba2V5XSlcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb21wb25lbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgICAgdHlwZTogc3RydWN0W2tleV1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbXBvbmVudHM7XG59O1xuLyoqXG4gKiBIYW5kbGUgc29tZSBmb3JtYXR0aW5nIG9mIHBhcmFtcyBmb3IgYmFja3dhcmRzIGNvbXBhdGFiaWxpdHkgd2l0aCBFdGhlcnMgVjRcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdFBhcmFtXG4gKiBAcGFyYW0ge1N0cmluZ30gLSB0eXBlXG4gKiBAcGFyYW0ge2FueX0gLSBwYXJhbVxuICogQHJldHVybiB7YW55fSAtIFRoZSBmb3JtYXR0ZWQgcGFyYW1cbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLmZvcm1hdFBhcmFtID0gZnVuY3Rpb24gKHR5cGUsIHBhcmFtKSB7XG4gICAgY29uc3QgcGFyYW1UeXBlQnl0ZXMgPSBuZXcgUmVnRXhwKC9eYnl0ZXMoWzAtOV0qKSQvKTtcbiAgICBjb25zdCBwYXJhbVR5cGVCeXRlc0FycmF5ID0gbmV3IFJlZ0V4cCgvXmJ5dGVzKFswLTldKilcXFtcXF0kLyk7XG4gICAgY29uc3QgcGFyYW1UeXBlTnVtYmVyID0gbmV3IFJlZ0V4cCgvXih1P2ludCkoWzAtOV0qKSQvKTtcbiAgICBjb25zdCBwYXJhbVR5cGVOdW1iZXJBcnJheSA9IG5ldyBSZWdFeHAoL14odT9pbnQpKFswLTldKilcXFtcXF0kLyk7XG4gICAgLy8gRm9ybWF0IEJOIHRvIHN0cmluZ1xuICAgIGlmICh1dGlscy5pc0JOKHBhcmFtKSB8fCB1dGlscy5pc0JpZ051bWJlcihwYXJhbSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtLnRvU3RyaW5nKDEwKTtcbiAgICB9XG4gICAgaWYgKHR5cGUubWF0Y2gocGFyYW1UeXBlQnl0ZXNBcnJheSkgfHwgdHlwZS5tYXRjaChwYXJhbVR5cGVOdW1iZXJBcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtLm1hcChwID0+IHRoaXMuZm9ybWF0UGFyYW0odHlwZS5yZXBsYWNlKCdbXScsICcnKSwgcCkpO1xuICAgIH1cbiAgICAvLyBGb3JtYXQgY29ycmVjdCB3aWR0aCBmb3IgdT9pbnRbMC05XSpcbiAgICBsZXQgbWF0Y2ggPSB0eXBlLm1hdGNoKHBhcmFtVHlwZU51bWJlcik7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XG4gICAgICAgIGlmIChzaXplIC8gOCA8IHBhcmFtLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gcGFkIHRvIGNvcnJlY3QgYml0IHdpZHRoXG4gICAgICAgICAgICBwYXJhbSA9IHV0aWxzLmxlZnRQYWQocGFyYW0sIHNpemUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZvcm1hdCBjb3JyZWN0IGxlbmd0aCBmb3IgYnl0ZXNbMC05XStcbiAgICBtYXRjaCA9IHR5cGUubWF0Y2gocGFyYW1UeXBlQnl0ZXMpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHBhcmFtKSkge1xuICAgICAgICAgICAgcGFyYW0gPSB1dGlscy50b0hleChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZm9ybWF0IHRvIGNvcnJlY3QgbGVuZ3RoXG4gICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICBpZiAoc2l6ZSkge1xuICAgICAgICAgICAgbGV0IG1heFNpemUgPSBzaXplICogMjtcbiAgICAgICAgICAgIGlmIChwYXJhbS5zdWJzdHJpbmcoMCwgMikgPT09ICcweCcpIHtcbiAgICAgICAgICAgICAgICBtYXhTaXplICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW0ubGVuZ3RoIDwgbWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgIC8vIHBhZCB0byBjb3JyZWN0IGxlbmd0aFxuICAgICAgICAgICAgICAgIHBhcmFtID0gdXRpbHMucmlnaHRQYWQocGFyYW0sIHNpemUgKiAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBmb3JtYXQgb2RkLWxlbmd0aCBieXRlcyB0byBldmVuLWxlbmd0aFxuICAgICAgICBpZiAocGFyYW0ubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgICAgICAgICAgcGFyYW0gPSAnMHgwJyArIHBhcmFtLnN1YnN0cmluZygyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyYW07XG59O1xuLyoqXG4gKiBFbmNvZGVzIGEgZnVuY3Rpb24gY2FsbCBmcm9tIGl0cyBqc29uIGludGVyZmFjZSBhbmQgcGFyYW1ldGVycy5cbiAqXG4gKiBAbWV0aG9kIGVuY29kZUZ1bmN0aW9uQ2FsbFxuICogQHBhcmFtIHtBcnJheX0ganNvbkludGVyZmFjZVxuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBlbmNvZGVkIEFCSSBmb3IgdGhpcyBmdW5jdGlvbiBjYWxsXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5lbmNvZGVGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoanNvbkludGVyZmFjZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RlRnVuY3Rpb25TaWduYXR1cmUoanNvbkludGVyZmFjZSkgKyB0aGlzLmVuY29kZVBhcmFtZXRlcnMoanNvbkludGVyZmFjZS5pbnB1dHMsIHBhcmFtcykucmVwbGFjZSgnMHgnLCAnJyk7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZWNvZGUgYnl0ZXMgdG8gcGxhaW4gcGFyYW1cbiAqXG4gKiBAbWV0aG9kIGRlY29kZVBhcmFtZXRlclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBieXRlc1xuICogQHJldHVybiB7T2JqZWN0fSBwbGFpbiBwYXJhbVxuICovXG5BQklDb2Rlci5wcm90b3R5cGUuZGVjb2RlUGFyYW1ldGVyID0gZnVuY3Rpb24gKHR5cGUsIGJ5dGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlUGFyYW1ldGVycyhbdHlwZV0sIGJ5dGVzKVswXTtcbn07XG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGRlY29kZSBsaXN0IG9mIHBhcmFtc1xuICpcbiAqIEBtZXRob2QgZGVjb2RlUGFyYW1ldGVyXG4gKiBAcGFyYW0ge0FycmF5fSBvdXRwdXRzXG4gKiBAcGFyYW0ge1N0cmluZ30gYnl0ZXNcbiAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBvZiBwbGFpbiBwYXJhbXNcbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLmRlY29kZVBhcmFtZXRlcnMgPSBmdW5jdGlvbiAob3V0cHV0cywgYnl0ZXMpIHtcbiAgICByZXR1cm4gdGhpcy5kZWNvZGVQYXJhbWV0ZXJzV2l0aChvdXRwdXRzLCBieXRlcywgZmFsc2UpO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGVjb2RlIGxpc3Qgb2YgcGFyYW1zXG4gKlxuICogQG1ldGhvZCBkZWNvZGVQYXJhbWV0ZXJcbiAqIEBwYXJhbSB7QXJyYXl9IG91dHB1dHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBieXRlc1xuICogQHBhcmFtIHtCb29sZWFufSBsb29zZVxuICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9mIHBsYWluIHBhcmFtc1xuICovXG5BQklDb2Rlci5wcm90b3R5cGUuZGVjb2RlUGFyYW1ldGVyc1dpdGggPSBmdW5jdGlvbiAob3V0cHV0cywgYnl0ZXMsIGxvb3NlKSB7XG4gICAgaWYgKG91dHB1dHMubGVuZ3RoID4gMCAmJiAoIWJ5dGVzIHx8IGJ5dGVzID09PSAnMHgnIHx8IGJ5dGVzID09PSAnMFgnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JldHVybmVkIHZhbHVlcyBhcmVuXFwndCB2YWxpZCwgZGlkIGl0IHJ1biBPdXQgb2YgR2FzPyAnICtcbiAgICAgICAgICAgICdZb3UgbWlnaHQgYWxzbyBzZWUgdGhpcyBlcnJvciBpZiB5b3UgYXJlIG5vdCB1c2luZyB0aGUgJyArXG4gICAgICAgICAgICAnY29ycmVjdCBBQkkgZm9yIHRoZSBjb250cmFjdCB5b3UgYXJlIHJldHJpZXZpbmcgZGF0YSBmcm9tLCAnICtcbiAgICAgICAgICAgICdyZXF1ZXN0aW5nIGRhdGEgZnJvbSBhIGJsb2NrIG51bWJlciB0aGF0IGRvZXMgbm90IGV4aXN0LCAnICtcbiAgICAgICAgICAgICdvciBxdWVyeWluZyBhIG5vZGUgd2hpY2ggaXMgbm90IGZ1bGx5IHN5bmNlZC4nKTtcbiAgICB9XG4gICAgdmFyIHJlcyA9IGV0aGVyc0FiaUNvZGVyLmRlY29kZSh0aGlzLm1hcFR5cGVzKG91dHB1dHMpLCAnMHgnICsgYnl0ZXMucmVwbGFjZSgvMHgvaSwgJycpLCBsb29zZSk7XG4gICAgdmFyIHJldHVyblZhbHVlID0gbmV3IFJlc3VsdCgpO1xuICAgIHJldHVyblZhbHVlLl9fbGVuZ3RoX18gPSAwO1xuICAgIG91dHB1dHMuZm9yRWFjaChmdW5jdGlvbiAob3V0cHV0LCBpKSB7XG4gICAgICAgIHZhciBkZWNvZGVkVmFsdWUgPSByZXNbcmV0dXJuVmFsdWUuX19sZW5ndGhfX107XG4gICAgICAgIGRlY29kZWRWYWx1ZSA9IChkZWNvZGVkVmFsdWUgPT09ICcweCcpID8gbnVsbCA6IGRlY29kZWRWYWx1ZTtcbiAgICAgICAgcmV0dXJuVmFsdWVbaV0gPSBkZWNvZGVkVmFsdWU7XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KG91dHB1dCkgJiYgb3V0cHV0Lm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlW291dHB1dC5uYW1lXSA9IGRlY29kZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5WYWx1ZS5fX2xlbmd0aF9fKys7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xufTtcbi8qKlxuICogRGVjb2RlcyBldmVudHMgbm9uLSBhbmQgaW5kZXhlZCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBtZXRob2QgZGVjb2RlTG9nXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRzXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICogQHBhcmFtIHtBcnJheX0gdG9waWNzXG4gKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2YgcGxhaW4gcGFyYW1zXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5kZWNvZGVMb2cgPSBmdW5jdGlvbiAoaW5wdXRzLCBkYXRhLCB0b3BpY3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRvcGljcyA9IF8uaXNBcnJheSh0b3BpY3MpID8gdG9waWNzIDogW3RvcGljc107XG4gICAgZGF0YSA9IGRhdGEgfHwgJyc7XG4gICAgdmFyIG5vdEluZGV4ZWRJbnB1dHMgPSBbXTtcbiAgICB2YXIgaW5kZXhlZFBhcmFtcyA9IFtdO1xuICAgIHZhciB0b3BpY0NvdW50ID0gMDtcbiAgICAvLyBUT0RPIGNoZWNrIGZvciBhbm9ueW1vdXMgbG9ncz9cbiAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQsIGkpIHtcbiAgICAgICAgaWYgKGlucHV0LmluZGV4ZWQpIHtcbiAgICAgICAgICAgIGluZGV4ZWRQYXJhbXNbaV0gPSAoWydib29sJywgJ2ludCcsICd1aW50JywgJ2FkZHJlc3MnLCAnZml4ZWQnLCAndWZpeGVkJ10uZmluZChmdW5jdGlvbiAoc3RhdGljVHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dC50eXBlLmluZGV4T2Yoc3RhdGljVHlwZSkgIT09IC0xO1xuICAgICAgICAgICAgfSkpID8gX3RoaXMuZGVjb2RlUGFyYW1ldGVyKGlucHV0LnR5cGUsIHRvcGljc1t0b3BpY0NvdW50XSkgOiB0b3BpY3NbdG9waWNDb3VudF07XG4gICAgICAgICAgICB0b3BpY0NvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub3RJbmRleGVkSW5wdXRzW2ldID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgbm9uSW5kZXhlZERhdGEgPSBkYXRhO1xuICAgIHZhciBub3RJbmRleGVkUGFyYW1zID0gKG5vbkluZGV4ZWREYXRhKSA/IHRoaXMuZGVjb2RlUGFyYW1ldGVyc1dpdGgobm90SW5kZXhlZElucHV0cywgbm9uSW5kZXhlZERhdGEsIHRydWUpIDogW107XG4gICAgdmFyIHJldHVyblZhbHVlID0gbmV3IFJlc3VsdCgpO1xuICAgIHJldHVyblZhbHVlLl9fbGVuZ3RoX18gPSAwO1xuICAgIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXMsIGkpIHtcbiAgICAgICAgcmV0dXJuVmFsdWVbaV0gPSAocmVzLnR5cGUgPT09ICdzdHJpbmcnKSA/ICcnIDogbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBub3RJbmRleGVkUGFyYW1zW2ldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWVbaV0gPSBub3RJbmRleGVkUGFyYW1zW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXhlZFBhcmFtc1tpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlW2ldID0gaW5kZXhlZFBhcmFtc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzLm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlW3Jlcy5uYW1lXSA9IHJldHVyblZhbHVlW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblZhbHVlLl9fbGVuZ3RoX18rKztcbiAgICB9KTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG59O1xudmFyIGNvZGVyID0gbmV3IEFCSUNvZGVyKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGNvZGVyO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/web3-eth-abi/lib/index.js\n");

/***/ })

}]);