/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendor/web3-core-method"],{

/***/ "./node_modules/web3-core-method/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/web3-core-method/lib/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\nvar _ = __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore.js\");\nvar errors = __webpack_require__(/*! web3-core-helpers */ \"./node_modules/web3-core-helpers/lib/index.js\").errors;\nvar formatters = __webpack_require__(/*! web3-core-helpers */ \"./node_modules/web3-core-helpers/lib/index.js\").formatters;\nvar utils = __webpack_require__(/*! web3-utils */ \"./node_modules/web3-utils/lib/index.js\");\nvar promiEvent = __webpack_require__(/*! web3-core-promievent */ \"./node_modules/web3-core-promievent/lib/index.js\");\nvar Subscriptions = __webpack_require__(/*! web3-core-subscriptions */ \"./node_modules/web3-core-subscriptions/lib/index.js\").subscriptions;\nvar EthersTransactionUtils = __webpack_require__(/*! @ethersproject/transactions */ \"./node_modules/@ethersproject/transactions/lib.esm/index.js\");\nvar Method = function Method(options) {\n    if (!options.call || !options.name) {\n        throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n    }\n    this.name = options.name;\n    this.call = options.call;\n    this.params = options.params || 0;\n    this.inputFormatter = options.inputFormatter;\n    this.outputFormatter = options.outputFormatter;\n    this.transformPayload = options.transformPayload;\n    this.extraFormatters = options.extraFormatters;\n    this.abiCoder = options.abiCoder; // Will be used to encode the revert reason string\n    this.requestManager = options.requestManager;\n    // reference to eth.accounts\n    this.accounts = options.accounts;\n    this.defaultBlock = options.defaultBlock || 'latest';\n    this.defaultAccount = options.defaultAccount || null;\n    this.transactionBlockTimeout = options.transactionBlockTimeout || 50;\n    this.transactionConfirmationBlocks = options.transactionConfirmationBlocks || 24;\n    this.transactionPollingTimeout = options.transactionPollingTimeout || 750;\n    this.defaultCommon = options.defaultCommon;\n    this.defaultChain = options.defaultChain;\n    this.defaultHardfork = options.defaultHardfork;\n    this.handleRevert = options.handleRevert;\n};\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n    this.requestManager = requestManager;\n    // reference to eth.accounts\n    if (accounts) {\n        this.accounts = accounts;\n    }\n};\nMethod.prototype.createFunction = function (requestManager, accounts) {\n    var func = this.buildCall();\n    func.call = this.call;\n    this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n    return func;\n};\nMethod.prototype.attachToObject = function (obj) {\n    var func = this.buildCall();\n    func.call = this.call;\n    var name = this.name.split('.');\n    if (name.length > 1) {\n        obj[name[0]] = obj[name[0]] || {};\n        obj[name[0]][name[1]] = func;\n    }\n    else {\n        obj[name[0]] = func;\n    }\n};\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\nMethod.prototype.getCall = function (args) {\n    return _.isFunction(this.call) ? this.call(args) : this.call;\n};\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nMethod.prototype.extractCallback = function (args) {\n    if (_.isFunction(args[args.length - 1])) {\n        return args.pop(); // modify the args array!\n    }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nMethod.prototype.validateArgs = function (args) {\n    if (args.length !== this.params) {\n        throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n    }\n};\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nMethod.prototype.formatInput = function (args) {\n    var _this = this;\n    if (!this.inputFormatter) {\n        return args;\n    }\n    return this.inputFormatter.map(function (formatter, index) {\n        // bind this for defaultBlock, and defaultAccount\n        return formatter ? formatter.call(_this, args[index]) : args[index];\n    });\n};\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\nMethod.prototype.formatOutput = function (result) {\n    var _this = this;\n    if (_.isArray(result)) {\n        return result.map(function (res) {\n            return _this.outputFormatter && res ? _this.outputFormatter(res) : res;\n        });\n    }\n    else {\n        return this.outputFormatter && result ? this.outputFormatter(result) : result;\n    }\n};\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nMethod.prototype.toPayload = function (args) {\n    var call = this.getCall(args);\n    var callback = this.extractCallback(args);\n    var params = this.formatInput(args);\n    this.validateArgs(params);\n    var payload = {\n        method: call,\n        params: params,\n        callback: callback\n    };\n    if (this.transformPayload) {\n        payload = this.transformPayload(payload);\n    }\n    return payload;\n};\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n    var method = this, promiseResolved = false, canUnsubscribe = true, timeoutCount = 0, confirmationCount = 0, intervalId = null, lastBlock = null, receiptJSON = '', gasProvided = (_.isObject(payload.params[0]) && payload.params[0].gas) ? payload.params[0].gas : null, isContractDeployment = _.isObject(payload.params[0]) &&\n        payload.params[0].data &&\n        payload.params[0].from &&\n        !payload.params[0].to, hasBytecode = isContractDeployment && payload.params[0].data.length > 2;\n    // add custom send Methods\n    var _ethereumCalls = [\n        new Method({\n            name: 'getBlockByNumber',\n            call: 'eth_getBlockByNumber',\n            params: 2,\n            inputFormatter: [formatters.inputBlockNumberFormatter, function (val) {\n                    return !!val;\n                }],\n            outputFormatter: formatters.outputBlockFormatter\n        }),\n        new Method({\n            name: 'getTransactionReceipt',\n            call: 'eth_getTransactionReceipt',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: formatters.outputTransactionReceiptFormatter\n        }),\n        new Method({\n            name: 'getCode',\n            call: 'eth_getCode',\n            params: 2,\n            inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n        }),\n        new Method({\n            name: 'getTransactionByHash',\n            call: 'eth_getTransactionByHash',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: formatters.outputTransactionFormatter\n        }),\n        new Subscriptions({\n            name: 'subscribe',\n            type: 'eth',\n            subscriptions: {\n                'newBlockHeaders': {\n                    subscriptionName: 'newHeads',\n                    params: 0,\n                    outputFormatter: formatters.outputBlockFormatter\n                }\n            }\n        })\n    ];\n    // attach methods to this._ethereumCall\n    var _ethereumCall = {};\n    _.each(_ethereumCalls, function (mthd) {\n        mthd.attachToObject(_ethereumCall);\n        mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n    });\n    // fire \"receipt\" and confirmation events and resolve after\n    var checkConfirmation = function (existingReceipt, isPolling, err, blockHeader, sub) {\n        if (!err) {\n            // create fake unsubscribe\n            if (!sub) {\n                sub = {\n                    unsubscribe: function () {\n                        clearInterval(intervalId);\n                    }\n                };\n            }\n            // if we have a valid receipt we don't need to send a request\n            return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result))\n                // catch error from requesting receipt\n                .catch(function (err) {\n                sub.unsubscribe();\n                promiseResolved = true;\n                utils._fireError({\n                    message: 'Failed to check for transaction receipt:',\n                    data: err\n                }, defer.eventEmitter, defer.reject);\n            })\n                // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n                .then(async function (receipt) {\n                if (!receipt || !receipt.blockHash) {\n                    throw new Error('Receipt missing or blockHash null');\n                }\n                // apply extra formatters\n                if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n                    receipt = method.extraFormatters.receiptFormatter(receipt);\n                }\n                // check if confirmation listener exists\n                if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                    var block;\n                    // If there was an immediately retrieved receipt, it's already\n                    // been confirmed by the direct call to checkConfirmation needed\n                    // for parity instant-seal\n                    if (existingReceipt === undefined || confirmationCount !== 0) {\n                        // Get latest block to emit with confirmation\n                        var latestBlock = await _ethereumCall.getBlockByNumber('latest');\n                        var latestBlockHash = latestBlock ? latestBlock.hash : null;\n                        if (isPolling) { // Check if actually a new block is existing on polling\n                            if (lastBlock) {\n                                block = await _ethereumCall.getBlockByNumber(lastBlock.number + 1);\n                                if (block) {\n                                    lastBlock = block;\n                                    defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                                }\n                            }\n                            else {\n                                block = await _ethereumCall.getBlockByNumber(receipt.blockNumber);\n                                lastBlock = block;\n                                defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                            }\n                        }\n                        else {\n                            defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                        }\n                    }\n                    if ((isPolling && block) || !isPolling) {\n                        confirmationCount++;\n                    }\n                    canUnsubscribe = false;\n                    if (confirmationCount === method.transactionConfirmationBlocks + 1) { // add 1 so we account for conf 0\n                        sub.unsubscribe();\n                        defer.eventEmitter.removeAllListeners();\n                    }\n                }\n                return receipt;\n            })\n                // CHECK for CONTRACT DEPLOYMENT\n                .then(async function (receipt) {\n                if (isContractDeployment && !promiseResolved) {\n                    if (!receipt.contractAddress) {\n                        if (canUnsubscribe) {\n                            sub.unsubscribe();\n                            promiseResolved = true;\n                        }\n                        utils._fireError(errors.NoContractAddressFoundError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                        return;\n                    }\n                    var code;\n                    try {\n                        code = await _ethereumCall.getCode(receipt.contractAddress);\n                    }\n                    catch (err) {\n                        // ignore;\n                    }\n                    if (!code) {\n                        return;\n                    }\n                    // If deployment is status.true and there was a real\n                    // bytecode string, assume it was successful.\n                    var deploymentSuccess = receipt.status === true && hasBytecode;\n                    if (deploymentSuccess || code.length > 2) {\n                        defer.eventEmitter.emit('receipt', receipt);\n                        // if contract, return instance instead of receipt\n                        if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                            defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n                        }\n                        else {\n                            defer.resolve(receipt);\n                        }\n                        // need to remove listeners, as they aren't removed automatically when succesfull\n                        if (canUnsubscribe) {\n                            defer.eventEmitter.removeAllListeners();\n                        }\n                    }\n                    else {\n                        utils._fireError(errors.ContractCodeNotStoredError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                    }\n                    if (canUnsubscribe) {\n                        sub.unsubscribe();\n                    }\n                    promiseResolved = true;\n                }\n                return receipt;\n            })\n                // CHECK for normal tx check for receipt only\n                .then(async function (receipt) {\n                if (!isContractDeployment && !promiseResolved) {\n                    if (!receipt.outOfGas &&\n                        (!gasProvided || gasProvided !== receipt.gasUsed) &&\n                        (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n                        defer.eventEmitter.emit('receipt', receipt);\n                        defer.resolve(receipt);\n                        // need to remove listeners, as they aren't removed automatically when succesfull\n                        if (canUnsubscribe) {\n                            defer.eventEmitter.removeAllListeners();\n                        }\n                    }\n                    else {\n                        receiptJSON = JSON.stringify(receipt, null, 2);\n                        if (receipt.status === false || receipt.status === '0x0') {\n                            try {\n                                var revertMessage = null;\n                                if (method.handleRevert &&\n                                    (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction')) {\n                                    var txReplayOptions = payload.params[0];\n                                    // If send was raw, fetch the transaction and reconstitute the\n                                    // original params so they can be replayed with `eth_call`\n                                    if (method.call === 'eth_sendRawTransaction') {\n                                        var rawTransactionHex = payload.params[0];\n                                        var parsedTx = EthersTransactionUtils.parse(rawTransactionHex);\n                                        txReplayOptions = formatters.inputTransactionFormatter({\n                                            data: parsedTx.data,\n                                            to: parsedTx.to,\n                                            from: parsedTx.from,\n                                            gas: parsedTx.gasLimit.toHexString(),\n                                            gasPrice: parsedTx.gasPrice.toHexString(),\n                                            value: parsedTx.value.toHexString()\n                                        });\n                                    }\n                                    // Get revert reason string with eth_call\n                                    revertMessage = await method.getRevertReason(txReplayOptions, receipt.blockNumber);\n                                    if (revertMessage) { // Only throw a revert error if a revert reason is existing\n                                        utils._fireError(errors.TransactionRevertInstructionError(revertMessage.reason, revertMessage.signature, receipt), defer.eventEmitter, defer.reject, null, receipt);\n                                    }\n                                    else {\n                                        throw false; // Throw false and let the try/catch statement handle the error correctly after\n                                    }\n                                }\n                                else {\n                                    throw false; // Throw false and let the try/catch statement handle the error correctly after\n                                }\n                            }\n                            catch (error) {\n                                // Throw an normal revert error if no revert reason is given or the detection of it is disabled\n                                utils._fireError(errors.TransactionRevertedWithoutReasonError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                            }\n                        }\n                        else {\n                            // Throw OOG if status is not existing and provided gas and used gas are equal\n                            utils._fireError(errors.TransactionOutOfGasError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                        }\n                    }\n                    if (canUnsubscribe) {\n                        sub.unsubscribe();\n                    }\n                    promiseResolved = true;\n                }\n            })\n                // time out the transaction if not mined after 50 blocks\n                .catch(function () {\n                timeoutCount++;\n                // check to see if we are http polling\n                if (!!isPolling) {\n                    // polling timeout is different than transactionBlockTimeout blocks since we are triggering every second\n                    if (timeoutCount - 1 >= method.transactionPollingTimeout) {\n                        sub.unsubscribe();\n                        promiseResolved = true;\n                        utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionPollingTimeout + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n                    }\n                }\n                else {\n                    if (timeoutCount - 1 >= method.transactionBlockTimeout) {\n                        sub.unsubscribe();\n                        promiseResolved = true;\n                        utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionBlockTimeout + ' blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n                    }\n                }\n            });\n        }\n        else {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError({\n                message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n                data: err\n            }, defer.eventEmitter, defer.reject);\n        }\n    };\n    // start watching for confirmation depending on the support features of the provider\n    var startWatching = function (existingReceipt) {\n        const startInterval = () => {\n            intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), 1000);\n        };\n        if (!this.requestManager.provider.on) {\n            startInterval();\n        }\n        else {\n            _ethereumCall.subscribe('newBlockHeaders', function (err, blockHeader, sub) {\n                if (err || !blockHeader) {\n                    // fall back to polling\n                    startInterval();\n                }\n                else {\n                    checkConfirmation(existingReceipt, false, err, blockHeader, sub);\n                }\n            });\n        }\n    }.bind(this);\n    // first check if we already have a confirmed transaction\n    _ethereumCall.getTransactionReceipt(result)\n        .then(function (receipt) {\n        if (receipt && receipt.blockHash) {\n            if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                // We must keep on watching for new Blocks, if a confirmation listener is present\n                startWatching(receipt);\n            }\n            checkConfirmation(receipt, false);\n        }\n        else if (!promiseResolved) {\n            startWatching();\n        }\n    })\n        .catch(function () {\n        if (!promiseResolved)\n            startWatching();\n    });\n};\nvar getWallet = function (from, accounts) {\n    var wallet = null;\n    // is index given\n    if (_.isNumber(from)) {\n        wallet = accounts.wallet[from];\n        // is account given\n    }\n    else if (_.isObject(from) && from.address && from.privateKey) {\n        wallet = from;\n        // search in wallet for address\n    }\n    else {\n        wallet = accounts.wallet[from.toLowerCase()];\n    }\n    return wallet;\n};\nMethod.prototype.buildCall = function () {\n    var method = this, isSendTx = (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction'), // || method.call === 'personal_sendTransaction'\n    isCall = (method.call === 'eth_call');\n    // actual send function\n    var send = function () {\n        var defer = promiEvent(!isSendTx), payload = method.toPayload(Array.prototype.slice.call(arguments));\n        // CALLBACK function\n        var sendTxCallback = function (err, result) {\n            if (method.handleRevert && isCall && method.abiCoder) {\n                var reasonData;\n                // Ganache / Geth <= 1.9.13 return the reason data as a successful eth_call response\n                // Geth >= 1.9.15 attaches the reason data to an error object.\n                // Geth 1.9.14 is missing revert reason (https://github.com/ethereum/web3.js/issues/3520)\n                if (!err && method.isRevertReasonString(result)) {\n                    reasonData = result.substring(10);\n                }\n                else if (err && err.data) {\n                    reasonData = err.data.substring(10);\n                }\n                if (reasonData) {\n                    var reason = method.abiCoder.decodeParameter('string', '0x' + reasonData);\n                    var signature = 'Error(String)';\n                    utils._fireError(errors.RevertInstructionError(reason, signature), defer.eventEmitter, defer.reject, payload.callback, {\n                        reason: reason,\n                        signature: signature\n                    });\n                    return;\n                }\n            }\n            try {\n                result = method.formatOutput(result);\n            }\n            catch (e) {\n                err = e;\n            }\n            if (result instanceof Error) {\n                err = result;\n            }\n            if (!err) {\n                if (payload.callback) {\n                    payload.callback(null, result);\n                }\n            }\n            else {\n                if (err.error) {\n                    err = err.error;\n                }\n                return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n            }\n            // return PROMISE\n            if (!isSendTx) {\n                if (!err) {\n                    defer.resolve(result);\n                }\n                // return PROMIEVENT\n            }\n            else {\n                defer.eventEmitter.emit('transactionHash', result);\n                method._confirmTransaction(defer, result, payload);\n            }\n        };\n        // SENDS the SIGNED SIGNATURE\n        var sendSignedTx = function (sign) {\n            var signedPayload = _.extend({}, payload, {\n                method: 'eth_sendRawTransaction',\n                params: [sign.rawTransaction]\n            });\n            method.requestManager.send(signedPayload, sendTxCallback);\n        };\n        var sendRequest = function (payload, method) {\n            if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n                var wallet;\n                // ETH_SENDTRANSACTION\n                if (payload.method === 'eth_sendTransaction') {\n                    var tx = payload.params[0];\n                    wallet = getWallet((_.isObject(tx)) ? tx.from : null, method.accounts);\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var txOptions = _.omit(tx, 'from');\n                        if (method.defaultChain && !txOptions.chain) {\n                            txOptions.chain = method.defaultChain;\n                        }\n                        if (method.defaultHardfork && !txOptions.hardfork) {\n                            txOptions.hardfork = method.defaultHardfork;\n                        }\n                        if (method.defaultCommon && !txOptions.common) {\n                            txOptions.common = method.defaultCommon;\n                        }\n                        method.accounts.signTransaction(txOptions, wallet.privateKey)\n                            .then(sendSignedTx)\n                            .catch(function (err) {\n                            if (_.isFunction(defer.eventEmitter.listeners) && defer.eventEmitter.listeners('error').length) {\n                                try {\n                                    defer.eventEmitter.emit('error', err);\n                                }\n                                catch (err) {\n                                    // Ignore userland error prevent it to bubble up within web3.\n                                }\n                                defer.eventEmitter.removeAllListeners();\n                                defer.eventEmitter.catch(function () {\n                                });\n                            }\n                            defer.reject(err);\n                        });\n                        return;\n                    }\n                    // ETH_SIGN\n                }\n                else if (payload.method === 'eth_sign') {\n                    var data = payload.params[1];\n                    wallet = getWallet(payload.params[0], method.accounts);\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var sign = method.accounts.sign(data, wallet.privateKey);\n                        if (payload.callback) {\n                            payload.callback(null, sign.signature);\n                        }\n                        defer.resolve(sign.signature);\n                        return;\n                    }\n                }\n            }\n            return method.requestManager.send(payload, sendTxCallback);\n        };\n        // Send the actual transaction\n        if (isSendTx && _.isObject(payload.params[0]) && typeof payload.params[0].gasPrice === 'undefined') {\n            var getGasPrice = (new Method({\n                name: 'getGasPrice',\n                call: 'eth_gasPrice',\n                params: 0\n            })).createFunction(method.requestManager);\n            getGasPrice(function (err, gasPrice) {\n                if (gasPrice) {\n                    payload.params[0].gasPrice = gasPrice;\n                }\n                if (isSendTx) {\n                    setTimeout(() => {\n                        defer.eventEmitter.emit('sending', payload);\n                    }, 0);\n                }\n                sendRequest(payload, method);\n            });\n        }\n        else {\n            if (isSendTx) {\n                setTimeout(() => {\n                    defer.eventEmitter.emit('sending', payload);\n                }, 0);\n            }\n            sendRequest(payload, method);\n        }\n        if (isSendTx) {\n            setTimeout(() => {\n                defer.eventEmitter.emit('sent', payload);\n            }, 0);\n        }\n        return defer.eventEmitter;\n    };\n    // necessary to attach things to the method\n    send.method = method;\n    // necessary for batch requests\n    send.request = this.request.bind(this);\n    return send;\n};\n/**\n * Returns the revert reason string if existing or otherwise false.\n *\n * @method getRevertReason\n *\n * @param {Object} txOptions\n * @param {Number} blockNumber\n *\n * @returns {Promise<Boolean|String>}\n */\nMethod.prototype.getRevertReason = function (txOptions, blockNumber) {\n    var self = this;\n    return new Promise(function (resolve, reject) {\n        (new Method({\n            name: 'call',\n            call: 'eth_call',\n            params: 2,\n            abiCoder: self.abiCoder,\n            handleRevert: true\n        }))\n            .createFunction(self.requestManager)(txOptions, utils.numberToHex(blockNumber))\n            .then(function () {\n            resolve(false);\n        })\n            .catch(function (error) {\n            if (error.reason) {\n                resolve({\n                    reason: error.reason,\n                    signature: error.signature\n                });\n            }\n            else {\n                reject(error);\n            }\n        });\n    });\n};\n/**\n * Checks if the given hex string is a revert message from the EVM\n *\n * @method isRevertReasonString\n *\n * @param {String} data - Hex string prefixed with 0x\n *\n * @returns {Boolean}\n */\nMethod.prototype.isRevertReasonString = function (data) {\n    return _.isString(data) && ((data.length - 2) / 2) % 32 === 4 && data.substring(0, 10) === '0x08c379a0';\n};\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\nMethod.prototype.request = function () {\n    var payload = this.toPayload(Array.prototype.slice.call(arguments));\n    payload.format = this.formatOutput.bind(this);\n    return payload;\n};\nmodule.exports = Method;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2ViMy1jb3JlLW1ldGhvZC9saWIvaW5kZXguanM/Nzc4OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixRQUFRLG1CQUFPLENBQUMsMkRBQVk7QUFDNUIsYUFBYSxvR0FBbUM7QUFDaEQsaUJBQWlCLHdHQUF1QztBQUN4RCxZQUFZLG1CQUFPLENBQUMsMERBQVk7QUFDaEMsaUJBQWlCLG1CQUFPLENBQUMsOEVBQXNCO0FBQy9DLG9CQUFvQix1SEFBZ0Q7QUFDcEUsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQTZCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2ViMy1jb3JlLW1ldGhvZC9saWIvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBpbmRleC5qc1xuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAcGFyaXR5LmlvPlxuICogQGRhdGUgMjAxN1xuICovXG4ndXNlIHN0cmljdCc7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCd3ZWIzLWNvcmUtaGVscGVycycpLmVycm9ycztcbnZhciBmb3JtYXR0ZXJzID0gcmVxdWlyZSgnd2ViMy1jb3JlLWhlbHBlcnMnKS5mb3JtYXR0ZXJzO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnd2ViMy11dGlscycpO1xudmFyIHByb21pRXZlbnQgPSByZXF1aXJlKCd3ZWIzLWNvcmUtcHJvbWlldmVudCcpO1xudmFyIFN1YnNjcmlwdGlvbnMgPSByZXF1aXJlKCd3ZWIzLWNvcmUtc3Vic2NyaXB0aW9ucycpLnN1YnNjcmlwdGlvbnM7XG52YXIgRXRoZXJzVHJhbnNhY3Rpb25VdGlscyA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L3RyYW5zYWN0aW9ucycpO1xudmFyIE1ldGhvZCA9IGZ1bmN0aW9uIE1ldGhvZChvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmNhbGwgfHwgIW9wdGlvbnMubmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gY3JlYXRpbmcgYSBtZXRob2QgeW91IG5lZWQgdG8gcHJvdmlkZSBhdCBsZWFzdCB0aGUgXCJuYW1lXCIgYW5kIFwiY2FsbFwiIHByb3BlcnR5LicpO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgdGhpcy5jYWxsID0gb3B0aW9ucy5jYWxsO1xuICAgIHRoaXMucGFyYW1zID0gb3B0aW9ucy5wYXJhbXMgfHwgMDtcbiAgICB0aGlzLmlucHV0Rm9ybWF0dGVyID0gb3B0aW9ucy5pbnB1dEZvcm1hdHRlcjtcbiAgICB0aGlzLm91dHB1dEZvcm1hdHRlciA9IG9wdGlvbnMub3V0cHV0Rm9ybWF0dGVyO1xuICAgIHRoaXMudHJhbnNmb3JtUGF5bG9hZCA9IG9wdGlvbnMudHJhbnNmb3JtUGF5bG9hZDtcbiAgICB0aGlzLmV4dHJhRm9ybWF0dGVycyA9IG9wdGlvbnMuZXh0cmFGb3JtYXR0ZXJzO1xuICAgIHRoaXMuYWJpQ29kZXIgPSBvcHRpb25zLmFiaUNvZGVyOyAvLyBXaWxsIGJlIHVzZWQgdG8gZW5jb2RlIHRoZSByZXZlcnQgcmVhc29uIHN0cmluZ1xuICAgIHRoaXMucmVxdWVzdE1hbmFnZXIgPSBvcHRpb25zLnJlcXVlc3RNYW5hZ2VyO1xuICAgIC8vIHJlZmVyZW5jZSB0byBldGguYWNjb3VudHNcbiAgICB0aGlzLmFjY291bnRzID0gb3B0aW9ucy5hY2NvdW50cztcbiAgICB0aGlzLmRlZmF1bHRCbG9jayA9IG9wdGlvbnMuZGVmYXVsdEJsb2NrIHx8ICdsYXRlc3QnO1xuICAgIHRoaXMuZGVmYXVsdEFjY291bnQgPSBvcHRpb25zLmRlZmF1bHRBY2NvdW50IHx8IG51bGw7XG4gICAgdGhpcy50cmFuc2FjdGlvbkJsb2NrVGltZW91dCA9IG9wdGlvbnMudHJhbnNhY3Rpb25CbG9ja1RpbWVvdXQgfHwgNTA7XG4gICAgdGhpcy50cmFuc2FjdGlvbkNvbmZpcm1hdGlvbkJsb2NrcyA9IG9wdGlvbnMudHJhbnNhY3Rpb25Db25maXJtYXRpb25CbG9ja3MgfHwgMjQ7XG4gICAgdGhpcy50cmFuc2FjdGlvblBvbGxpbmdUaW1lb3V0ID0gb3B0aW9ucy50cmFuc2FjdGlvblBvbGxpbmdUaW1lb3V0IHx8IDc1MDtcbiAgICB0aGlzLmRlZmF1bHRDb21tb24gPSBvcHRpb25zLmRlZmF1bHRDb21tb247XG4gICAgdGhpcy5kZWZhdWx0Q2hhaW4gPSBvcHRpb25zLmRlZmF1bHRDaGFpbjtcbiAgICB0aGlzLmRlZmF1bHRIYXJkZm9yayA9IG9wdGlvbnMuZGVmYXVsdEhhcmRmb3JrO1xuICAgIHRoaXMuaGFuZGxlUmV2ZXJ0ID0gb3B0aW9ucy5oYW5kbGVSZXZlcnQ7XG59O1xuTWV0aG9kLnByb3RvdHlwZS5zZXRSZXF1ZXN0TWFuYWdlciA9IGZ1bmN0aW9uIChyZXF1ZXN0TWFuYWdlciwgYWNjb3VudHMpIHtcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyID0gcmVxdWVzdE1hbmFnZXI7XG4gICAgLy8gcmVmZXJlbmNlIHRvIGV0aC5hY2NvdW50c1xuICAgIGlmIChhY2NvdW50cykge1xuICAgICAgICB0aGlzLmFjY291bnRzID0gYWNjb3VudHM7XG4gICAgfVxufTtcbk1ldGhvZC5wcm90b3R5cGUuY3JlYXRlRnVuY3Rpb24gPSBmdW5jdGlvbiAocmVxdWVzdE1hbmFnZXIsIGFjY291bnRzKSB7XG4gICAgdmFyIGZ1bmMgPSB0aGlzLmJ1aWxkQ2FsbCgpO1xuICAgIGZ1bmMuY2FsbCA9IHRoaXMuY2FsbDtcbiAgICB0aGlzLnNldFJlcXVlc3RNYW5hZ2VyKHJlcXVlc3RNYW5hZ2VyIHx8IHRoaXMucmVxdWVzdE1hbmFnZXIsIGFjY291bnRzIHx8IHRoaXMuYWNjb3VudHMpO1xuICAgIHJldHVybiBmdW5jO1xufTtcbk1ldGhvZC5wcm90b3R5cGUuYXR0YWNoVG9PYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGZ1bmMgPSB0aGlzLmJ1aWxkQ2FsbCgpO1xuICAgIGZ1bmMuY2FsbCA9IHRoaXMuY2FsbDtcbiAgICB2YXIgbmFtZSA9IHRoaXMubmFtZS5zcGxpdCgnLicpO1xuICAgIGlmIChuYW1lLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgb2JqW25hbWVbMF1dID0gb2JqW25hbWVbMF1dIHx8IHt9O1xuICAgICAgICBvYmpbbmFtZVswXV1bbmFtZVsxXV0gPSBmdW5jO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb2JqW25hbWVbMF1dID0gZnVuYztcbiAgICB9XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZXRlcm1pbmUgbmFtZSBvZiB0aGUganNvbnJwYyBtZXRob2QgYmFzZWQgb24gYXJndW1lbnRzXG4gKlxuICogQG1ldGhvZCBnZXRDYWxsXG4gKiBAcGFyYW0ge0FycmF5fSBhcmd1bWVudHNcbiAqIEByZXR1cm4ge1N0cmluZ30gbmFtZSBvZiBqc29ucnBjIG1ldGhvZFxuICovXG5NZXRob2QucHJvdG90eXBlLmdldENhbGwgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odGhpcy5jYWxsKSA/IHRoaXMuY2FsbChhcmdzKSA6IHRoaXMuY2FsbDtcbn07XG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGV4dHJhY3QgY2FsbGJhY2sgZnJvbSBhcnJheSBvZiBhcmd1bWVudHMuIE1vZGlmaWVzIGlucHV0IHBhcmFtXG4gKlxuICogQG1ldGhvZCBleHRyYWN0Q2FsbGJhY2tcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3VtZW50c1xuICogQHJldHVybiB7RnVuY3Rpb258TnVsbH0gY2FsbGJhY2ssIGlmIGV4aXN0c1xuICovXG5NZXRob2QucHJvdG90eXBlLmV4dHJhY3RDYWxsYmFjayA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHJldHVybiBhcmdzLnBvcCgpOyAvLyBtb2RpZnkgdGhlIGFyZ3MgYXJyYXkhXG4gICAgfVxufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjaGVjayBpZiB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBpcyBjb3JyZWN0XG4gKlxuICogQG1ldGhvZCB2YWxpZGF0ZUFyZ3NcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3VtZW50c1xuICogQHRocm93cyB7RXJyb3J9IGlmIGl0IGlzIG5vdFxuICovXG5NZXRob2QucHJvdG90eXBlLnZhbGlkYXRlQXJncyA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSB0aGlzLnBhcmFtcykge1xuICAgICAgICB0aHJvdyBlcnJvcnMuSW52YWxpZE51bWJlck9mUGFyYW1zKGFyZ3MubGVuZ3RoLCB0aGlzLnBhcmFtcywgdGhpcy5uYW1lKTtcbiAgICB9XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGZvcm1hdCBpbnB1dCBhcmdzIG9mIG1ldGhvZFxuICpcbiAqIEBtZXRob2QgZm9ybWF0SW5wdXRcbiAqIEBwYXJhbSB7QXJyYXl9XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5mb3JtYXRJbnB1dCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoIXRoaXMuaW5wdXRGb3JtYXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlucHV0Rm9ybWF0dGVyLm1hcChmdW5jdGlvbiAoZm9ybWF0dGVyLCBpbmRleCkge1xuICAgICAgICAvLyBiaW5kIHRoaXMgZm9yIGRlZmF1bHRCbG9jaywgYW5kIGRlZmF1bHRBY2NvdW50XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIgPyBmb3JtYXR0ZXIuY2FsbChfdGhpcywgYXJnc1tpbmRleF0pIDogYXJnc1tpbmRleF07XG4gICAgfSk7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGZvcm1hdCBvdXRwdXQocmVzdWx0KSBvZiBtZXRob2RcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdE91dHB1dFxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUuZm9ybWF0T3V0cHV0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKF8uaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQubWFwKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5vdXRwdXRGb3JtYXR0ZXIgJiYgcmVzID8gX3RoaXMub3V0cHV0Rm9ybWF0dGVyKHJlcykgOiByZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0Rm9ybWF0dGVyICYmIHJlc3VsdCA/IHRoaXMub3V0cHV0Rm9ybWF0dGVyKHJlc3VsdCkgOiByZXN1bHQ7XG4gICAgfVxufTtcbi8qKlxuICogU2hvdWxkIGNyZWF0ZSBwYXlsb2FkIGZyb20gZ2l2ZW4gaW5wdXQgYXJnc1xuICpcbiAqIEBtZXRob2QgdG9QYXlsb2FkXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUudG9QYXlsb2FkID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgY2FsbCA9IHRoaXMuZ2V0Q2FsbChhcmdzKTtcbiAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLmV4dHJhY3RDYWxsYmFjayhhcmdzKTtcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5mb3JtYXRJbnB1dChhcmdzKTtcbiAgICB0aGlzLnZhbGlkYXRlQXJncyhwYXJhbXMpO1xuICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgICBtZXRob2Q6IGNhbGwsXG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICB9O1xuICAgIGlmICh0aGlzLnRyYW5zZm9ybVBheWxvYWQpIHtcbiAgICAgICAgcGF5bG9hZCA9IHRoaXMudHJhbnNmb3JtUGF5bG9hZChwYXlsb2FkKTtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59O1xuTWV0aG9kLnByb3RvdHlwZS5fY29uZmlybVRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKGRlZmVyLCByZXN1bHQsIHBheWxvYWQpIHtcbiAgICB2YXIgbWV0aG9kID0gdGhpcywgcHJvbWlzZVJlc29sdmVkID0gZmFsc2UsIGNhblVuc3Vic2NyaWJlID0gdHJ1ZSwgdGltZW91dENvdW50ID0gMCwgY29uZmlybWF0aW9uQ291bnQgPSAwLCBpbnRlcnZhbElkID0gbnVsbCwgbGFzdEJsb2NrID0gbnVsbCwgcmVjZWlwdEpTT04gPSAnJywgZ2FzUHJvdmlkZWQgPSAoXy5pc09iamVjdChwYXlsb2FkLnBhcmFtc1swXSkgJiYgcGF5bG9hZC5wYXJhbXNbMF0uZ2FzKSA/IHBheWxvYWQucGFyYW1zWzBdLmdhcyA6IG51bGwsIGlzQ29udHJhY3REZXBsb3ltZW50ID0gXy5pc09iamVjdChwYXlsb2FkLnBhcmFtc1swXSkgJiZcbiAgICAgICAgcGF5bG9hZC5wYXJhbXNbMF0uZGF0YSAmJlxuICAgICAgICBwYXlsb2FkLnBhcmFtc1swXS5mcm9tICYmXG4gICAgICAgICFwYXlsb2FkLnBhcmFtc1swXS50bywgaGFzQnl0ZWNvZGUgPSBpc0NvbnRyYWN0RGVwbG95bWVudCAmJiBwYXlsb2FkLnBhcmFtc1swXS5kYXRhLmxlbmd0aCA+IDI7XG4gICAgLy8gYWRkIGN1c3RvbSBzZW5kIE1ldGhvZHNcbiAgICB2YXIgX2V0aGVyZXVtQ2FsbHMgPSBbXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldEJsb2NrQnlOdW1iZXInLFxuICAgICAgICAgICAgY2FsbDogJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJyxcbiAgICAgICAgICAgIHBhcmFtczogMixcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXZhbDtcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVycy5vdXRwdXRCbG9ja0Zvcm1hdHRlclxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JyxcbiAgICAgICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbF0sXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlcnMub3V0cHV0VHJhbnNhY3Rpb25SZWNlaXB0Rm9ybWF0dGVyXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdnZXRDb2RlJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfZ2V0Q29kZScsXG4gICAgICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyLCBmb3JtYXR0ZXJzLmlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyXVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0VHJhbnNhY3Rpb25CeUhhc2gnLFxuICAgICAgICAgICAgY2FsbDogJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCcsXG4gICAgICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGxdLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXJzLm91dHB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgU3Vic2NyaXB0aW9ucyh7XG4gICAgICAgICAgICBuYW1lOiAnc3Vic2NyaWJlJyxcbiAgICAgICAgICAgIHR5cGU6ICdldGgnLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uczoge1xuICAgICAgICAgICAgICAgICduZXdCbG9ja0hlYWRlcnMnOiB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbk5hbWU6ICduZXdIZWFkcycsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogMCxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXJzLm91dHB1dEJsb2NrRm9ybWF0dGVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIF07XG4gICAgLy8gYXR0YWNoIG1ldGhvZHMgdG8gdGhpcy5fZXRoZXJldW1DYWxsXG4gICAgdmFyIF9ldGhlcmV1bUNhbGwgPSB7fTtcbiAgICBfLmVhY2goX2V0aGVyZXVtQ2FsbHMsIGZ1bmN0aW9uIChtdGhkKSB7XG4gICAgICAgIG10aGQuYXR0YWNoVG9PYmplY3QoX2V0aGVyZXVtQ2FsbCk7XG4gICAgICAgIG10aGQucmVxdWVzdE1hbmFnZXIgPSBtZXRob2QucmVxdWVzdE1hbmFnZXI7IC8vIGFzc2lnbiByYXRoZXIgdGhhbiBjYWxsIHNldFJlcXVlc3RNYW5hZ2VyKClcbiAgICB9KTtcbiAgICAvLyBmaXJlIFwicmVjZWlwdFwiIGFuZCBjb25maXJtYXRpb24gZXZlbnRzIGFuZCByZXNvbHZlIGFmdGVyXG4gICAgdmFyIGNoZWNrQ29uZmlybWF0aW9uID0gZnVuY3Rpb24gKGV4aXN0aW5nUmVjZWlwdCwgaXNQb2xsaW5nLCBlcnIsIGJsb2NrSGVhZGVyLCBzdWIpIHtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBmYWtlIHVuc3Vic2NyaWJlXG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHN1YiA9IHtcbiAgICAgICAgICAgICAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIHZhbGlkIHJlY2VpcHQgd2UgZG9uJ3QgbmVlZCB0byBzZW5kIGEgcmVxdWVzdFxuICAgICAgICAgICAgcmV0dXJuIChleGlzdGluZ1JlY2VpcHQgPyBwcm9taUV2ZW50LnJlc29sdmUoZXhpc3RpbmdSZWNlaXB0KSA6IF9ldGhlcmV1bUNhbGwuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHJlc3VsdCkpXG4gICAgICAgICAgICAgICAgLy8gY2F0Y2ggZXJyb3IgZnJvbSByZXF1ZXN0aW5nIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHByb21pc2VSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdXRpbHMuX2ZpcmVFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdGYWlsZWQgdG8gY2hlY2sgZm9yIHRyYW5zYWN0aW9uIHJlY2VpcHQ6JyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZXJyXG4gICAgICAgICAgICAgICAgfSwgZGVmZXIuZXZlbnRFbWl0dGVyLCBkZWZlci5yZWplY3QpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAvLyBpZiBDT05GSVJNQVRJT04gbGlzdGVuZXIgZXhpc3RzIGNoZWNrIGZvciBjb25maXJtYXRpb25zLCBieSBzZXR0aW5nIGNhblVuc3Vic2NyaWJlID0gZmFsc2VcbiAgICAgICAgICAgICAgICAudGhlbihhc3luYyBmdW5jdGlvbiAocmVjZWlwdCkge1xuICAgICAgICAgICAgICAgIGlmICghcmVjZWlwdCB8fCAhcmVjZWlwdC5ibG9ja0hhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWNlaXB0IG1pc3Npbmcgb3IgYmxvY2tIYXNoIG51bGwnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYXBwbHkgZXh0cmEgZm9ybWF0dGVyc1xuICAgICAgICAgICAgICAgIGlmIChtZXRob2QuZXh0cmFGb3JtYXR0ZXJzICYmIG1ldGhvZC5leHRyYUZvcm1hdHRlcnMucmVjZWlwdEZvcm1hdHRlcikge1xuICAgICAgICAgICAgICAgICAgICByZWNlaXB0ID0gbWV0aG9kLmV4dHJhRm9ybWF0dGVycy5yZWNlaXB0Rm9ybWF0dGVyKHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBjb25maXJtYXRpb24gbGlzdGVuZXIgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKGRlZmVyLmV2ZW50RW1pdHRlci5saXN0ZW5lcnMoJ2NvbmZpcm1hdGlvbicpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYW4gaW1tZWRpYXRlbHkgcmV0cmlldmVkIHJlY2VpcHQsIGl0J3MgYWxyZWFkeVxuICAgICAgICAgICAgICAgICAgICAvLyBiZWVuIGNvbmZpcm1lZCBieSB0aGUgZGlyZWN0IGNhbGwgdG8gY2hlY2tDb25maXJtYXRpb24gbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBwYXJpdHkgaW5zdGFudC1zZWFsXG4gICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1JlY2VpcHQgPT09IHVuZGVmaW5lZCB8fCBjb25maXJtYXRpb25Db3VudCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGxhdGVzdCBibG9jayB0byBlbWl0IHdpdGggY29uZmlybWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGF0ZXN0QmxvY2sgPSBhd2FpdCBfZXRoZXJldW1DYWxsLmdldEJsb2NrQnlOdW1iZXIoJ2xhdGVzdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhdGVzdEJsb2NrSGFzaCA9IGxhdGVzdEJsb2NrID8gbGF0ZXN0QmxvY2suaGFzaCA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQb2xsaW5nKSB7IC8vIENoZWNrIGlmIGFjdHVhbGx5IGEgbmV3IGJsb2NrIGlzIGV4aXN0aW5nIG9uIHBvbGxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gYXdhaXQgX2V0aGVyZXVtQ2FsbC5nZXRCbG9ja0J5TnVtYmVyKGxhc3RCbG9jay5udW1iZXIgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0QmxvY2sgPSBibG9jaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5lbWl0KCdjb25maXJtYXRpb24nLCBjb25maXJtYXRpb25Db3VudCwgcmVjZWlwdCwgbGF0ZXN0QmxvY2tIYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBhd2FpdCBfZXRoZXJldW1DYWxsLmdldEJsb2NrQnlOdW1iZXIocmVjZWlwdC5ibG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RCbG9jayA9IGJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIuZW1pdCgnY29uZmlybWF0aW9uJywgY29uZmlybWF0aW9uQ291bnQsIHJlY2VpcHQsIGxhdGVzdEJsb2NrSGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLmVtaXQoJ2NvbmZpcm1hdGlvbicsIGNvbmZpcm1hdGlvbkNvdW50LCByZWNlaXB0LCBsYXRlc3RCbG9ja0hhc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgoaXNQb2xsaW5nICYmIGJsb2NrKSB8fCAhaXNQb2xsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25Db3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhblVuc3Vic2NyaWJlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25Db3VudCA9PT0gbWV0aG9kLnRyYW5zYWN0aW9uQ29uZmlybWF0aW9uQmxvY2tzICsgMSkgeyAvLyBhZGQgMSBzbyB3ZSBhY2NvdW50IGZvciBjb25mIDBcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXB0O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAvLyBDSEVDSyBmb3IgQ09OVFJBQ1QgREVQTE9ZTUVOVFxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jIGZ1bmN0aW9uIChyZWNlaXB0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQ29udHJhY3REZXBsb3ltZW50ICYmICFwcm9taXNlUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWNlaXB0LmNvbnRyYWN0QWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhblVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZVJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLl9maXJlRXJyb3IoZXJyb3JzLk5vQ29udHJhY3RBZGRyZXNzRm91bmRFcnJvcihyZWNlaXB0KSwgZGVmZXIuZXZlbnRFbWl0dGVyLCBkZWZlci5yZWplY3QsIG51bGwsIHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2RlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGF3YWl0IF9ldGhlcmV1bUNhbGwuZ2V0Q29kZShyZWNlaXB0LmNvbnRyYWN0QWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGRlcGxveW1lbnQgaXMgc3RhdHVzLnRydWUgYW5kIHRoZXJlIHdhcyBhIHJlYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gYnl0ZWNvZGUgc3RyaW5nLCBhc3N1bWUgaXQgd2FzIHN1Y2Nlc3NmdWwuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXBsb3ltZW50U3VjY2VzcyA9IHJlY2VpcHQuc3RhdHVzID09PSB0cnVlICYmIGhhc0J5dGVjb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVwbG95bWVudFN1Y2Nlc3MgfHwgY29kZS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIuZW1pdCgncmVjZWlwdCcsIHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgY29udHJhY3QsIHJldHVybiBpbnN0YW5jZSBpbnN0ZWFkIG9mIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QuZXh0cmFGb3JtYXR0ZXJzICYmIG1ldGhvZC5leHRyYUZvcm1hdHRlcnMuY29udHJhY3REZXBsb3lGb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlKG1ldGhvZC5leHRyYUZvcm1hdHRlcnMuY29udHJhY3REZXBsb3lGb3JtYXR0ZXIocmVjZWlwdCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZShyZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gcmVtb3ZlIGxpc3RlbmVycywgYXMgdGhleSBhcmVuJ3QgcmVtb3ZlZCBhdXRvbWF0aWNhbGx5IHdoZW4gc3VjY2VzZnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhblVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMuX2ZpcmVFcnJvcihlcnJvcnMuQ29udHJhY3RDb2RlTm90U3RvcmVkRXJyb3IocmVjZWlwdCksIGRlZmVyLmV2ZW50RW1pdHRlciwgZGVmZXIucmVqZWN0LCBudWxsLCByZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuVW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXB0O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAvLyBDSEVDSyBmb3Igbm9ybWFsIHR4IGNoZWNrIGZvciByZWNlaXB0IG9ubHlcbiAgICAgICAgICAgICAgICAudGhlbihhc3luYyBmdW5jdGlvbiAocmVjZWlwdCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNDb250cmFjdERlcGxveW1lbnQgJiYgIXByb21pc2VSZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY2VpcHQub3V0T2ZHYXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICghZ2FzUHJvdmlkZWQgfHwgZ2FzUHJvdmlkZWQgIT09IHJlY2VpcHQuZ2FzVXNlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChyZWNlaXB0LnN0YXR1cyA9PT0gdHJ1ZSB8fCByZWNlaXB0LnN0YXR1cyA9PT0gJzB4MScgfHwgdHlwZW9mIHJlY2VpcHQuc3RhdHVzID09PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5lbWl0KCdyZWNlaXB0JywgcmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlKHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byByZW1vdmUgbGlzdGVuZXJzLCBhcyB0aGV5IGFyZW4ndCByZW1vdmVkIGF1dG9tYXRpY2FsbHkgd2hlbiBzdWNjZXNmdWxsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FuVW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0SlNPTiA9IEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQuc3RhdHVzID09PSBmYWxzZSB8fCByZWNlaXB0LnN0YXR1cyA9PT0gJzB4MCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV2ZXJ0TWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QuaGFuZGxlUmV2ZXJ0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWV0aG9kLmNhbGwgPT09ICdldGhfc2VuZFRyYW5zYWN0aW9uJyB8fCBtZXRob2QuY2FsbCA9PT0gJ2V0aF9zZW5kUmF3VHJhbnNhY3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR4UmVwbGF5T3B0aW9ucyA9IHBheWxvYWQucGFyYW1zWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgc2VuZCB3YXMgcmF3LCBmZXRjaCB0aGUgdHJhbnNhY3Rpb24gYW5kIHJlY29uc3RpdHV0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yaWdpbmFsIHBhcmFtcyBzbyB0aGV5IGNhbiBiZSByZXBsYXllZCB3aXRoIGBldGhfY2FsbGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QuY2FsbCA9PT0gJ2V0aF9zZW5kUmF3VHJhbnNhY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd1RyYW5zYWN0aW9uSGV4ID0gcGF5bG9hZC5wYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlZFR4ID0gRXRoZXJzVHJhbnNhY3Rpb25VdGlscy5wYXJzZShyYXdUcmFuc2FjdGlvbkhleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhSZXBsYXlPcHRpb25zID0gZm9ybWF0dGVycy5pbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcGFyc2VkVHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IHBhcnNlZFR4LnRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBwYXJzZWRUeC5mcm9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXM6IHBhcnNlZFR4Lmdhc0xpbWl0LnRvSGV4U3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhc1ByaWNlOiBwYXJzZWRUeC5nYXNQcmljZS50b0hleFN0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VkVHgudmFsdWUudG9IZXhTdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHJldmVydCByZWFzb24gc3RyaW5nIHdpdGggZXRoX2NhbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVydE1lc3NhZ2UgPSBhd2FpdCBtZXRob2QuZ2V0UmV2ZXJ0UmVhc29uKHR4UmVwbGF5T3B0aW9ucywgcmVjZWlwdC5ibG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV2ZXJ0TWVzc2FnZSkgeyAvLyBPbmx5IHRocm93IGEgcmV2ZXJ0IGVycm9yIGlmIGEgcmV2ZXJ0IHJlYXNvbiBpcyBleGlzdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLl9maXJlRXJyb3IoZXJyb3JzLlRyYW5zYWN0aW9uUmV2ZXJ0SW5zdHJ1Y3Rpb25FcnJvcihyZXZlcnRNZXNzYWdlLnJlYXNvbiwgcmV2ZXJ0TWVzc2FnZS5zaWduYXR1cmUsIHJlY2VpcHQpLCBkZWZlci5ldmVudEVtaXR0ZXIsIGRlZmVyLnJlamVjdCwgbnVsbCwgcmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBmYWxzZTsgLy8gVGhyb3cgZmFsc2UgYW5kIGxldCB0aGUgdHJ5L2NhdGNoIHN0YXRlbWVudCBoYW5kbGUgdGhlIGVycm9yIGNvcnJlY3RseSBhZnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZmFsc2U7IC8vIFRocm93IGZhbHNlIGFuZCBsZXQgdGhlIHRyeS9jYXRjaCBzdGF0ZW1lbnQgaGFuZGxlIHRoZSBlcnJvciBjb3JyZWN0bHkgYWZ0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhyb3cgYW4gbm9ybWFsIHJldmVydCBlcnJvciBpZiBubyByZXZlcnQgcmVhc29uIGlzIGdpdmVuIG9yIHRoZSBkZXRlY3Rpb24gb2YgaXQgaXMgZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMuX2ZpcmVFcnJvcihlcnJvcnMuVHJhbnNhY3Rpb25SZXZlcnRlZFdpdGhvdXRSZWFzb25FcnJvcihyZWNlaXB0KSwgZGVmZXIuZXZlbnRFbWl0dGVyLCBkZWZlci5yZWplY3QsIG51bGwsIHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRocm93IE9PRyBpZiBzdGF0dXMgaXMgbm90IGV4aXN0aW5nIGFuZCBwcm92aWRlZCBnYXMgYW5kIHVzZWQgZ2FzIGFyZSBlcXVhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLl9maXJlRXJyb3IoZXJyb3JzLlRyYW5zYWN0aW9uT3V0T2ZHYXNFcnJvcihyZWNlaXB0KSwgZGVmZXIuZXZlbnRFbWl0dGVyLCBkZWZlci5yZWplY3QsIG51bGwsIHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5VbnN1YnNjcmliZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZVJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC8vIHRpbWUgb3V0IHRoZSB0cmFuc2FjdGlvbiBpZiBub3QgbWluZWQgYWZ0ZXIgNTAgYmxvY2tzXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0Q291bnQrKztcbiAgICAgICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgd2UgYXJlIGh0dHAgcG9sbGluZ1xuICAgICAgICAgICAgICAgIGlmICghIWlzUG9sbGluZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBwb2xsaW5nIHRpbWVvdXQgaXMgZGlmZmVyZW50IHRoYW4gdHJhbnNhY3Rpb25CbG9ja1RpbWVvdXQgYmxvY2tzIHNpbmNlIHdlIGFyZSB0cmlnZ2VyaW5nIGV2ZXJ5IHNlY29uZFxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dENvdW50IC0gMSA+PSBtZXRob2QudHJhbnNhY3Rpb25Qb2xsaW5nVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMuX2ZpcmVFcnJvcihlcnJvcnMuVHJhbnNhY3Rpb25FcnJvcignVHJhbnNhY3Rpb24gd2FzIG5vdCBtaW5lZCB3aXRoaW4gJyArIG1ldGhvZC50cmFuc2FjdGlvblBvbGxpbmdUaW1lb3V0ICsgJyBzZWNvbmRzLCBwbGVhc2UgbWFrZSBzdXJlIHlvdXIgdHJhbnNhY3Rpb24gd2FzIHByb3Blcmx5IHNlbnQuIEJlIGF3YXJlIHRoYXQgaXQgbWlnaHQgc3RpbGwgYmUgbWluZWQhJyksIGRlZmVyLmV2ZW50RW1pdHRlciwgZGVmZXIucmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXRDb3VudCAtIDEgPj0gbWV0aG9kLnRyYW5zYWN0aW9uQmxvY2tUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB1dGlscy5fZmlyZUVycm9yKGVycm9ycy5UcmFuc2FjdGlvbkVycm9yKCdUcmFuc2FjdGlvbiB3YXMgbm90IG1pbmVkIHdpdGhpbiAnICsgbWV0aG9kLnRyYW5zYWN0aW9uQmxvY2tUaW1lb3V0ICsgJyBibG9ja3MsIHBsZWFzZSBtYWtlIHN1cmUgeW91ciB0cmFuc2FjdGlvbiB3YXMgcHJvcGVybHkgc2VudC4gQmUgYXdhcmUgdGhhdCBpdCBtaWdodCBzdGlsbCBiZSBtaW5lZCEnKSwgZGVmZXIuZXZlbnRFbWl0dGVyLCBkZWZlci5yZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHByb21pc2VSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICB1dGlscy5fZmlyZUVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIHN1YnNjcmliZSB0byBuZXcgbmV3QmxvY2tIZWFkZXJzIHRvIGNvbmZpcm0gdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRzLicsXG4gICAgICAgICAgICAgICAgZGF0YTogZXJyXG4gICAgICAgICAgICB9LCBkZWZlci5ldmVudEVtaXR0ZXIsIGRlZmVyLnJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIHN0YXJ0IHdhdGNoaW5nIGZvciBjb25maXJtYXRpb24gZGVwZW5kaW5nIG9uIHRoZSBzdXBwb3J0IGZlYXR1cmVzIG9mIHRoZSBwcm92aWRlclxuICAgIHZhciBzdGFydFdhdGNoaW5nID0gZnVuY3Rpb24gKGV4aXN0aW5nUmVjZWlwdCkge1xuICAgICAgICBjb25zdCBzdGFydEludGVydmFsID0gKCkgPT4ge1xuICAgICAgICAgICAgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKGNoZWNrQ29uZmlybWF0aW9uLmJpbmQobnVsbCwgZXhpc3RpbmdSZWNlaXB0LCB0cnVlKSwgMTAwMCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy5yZXF1ZXN0TWFuYWdlci5wcm92aWRlci5vbikge1xuICAgICAgICAgICAgc3RhcnRJbnRlcnZhbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2V0aGVyZXVtQ2FsbC5zdWJzY3JpYmUoJ25ld0Jsb2NrSGVhZGVycycsIGZ1bmN0aW9uIChlcnIsIGJsb2NrSGVhZGVyLCBzdWIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyIHx8ICFibG9ja0hlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBmYWxsIGJhY2sgdG8gcG9sbGluZ1xuICAgICAgICAgICAgICAgICAgICBzdGFydEludGVydmFsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGVja0NvbmZpcm1hdGlvbihleGlzdGluZ1JlY2VpcHQsIGZhbHNlLCBlcnIsIGJsb2NrSGVhZGVyLCBzdWIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIC8vIGZpcnN0IGNoZWNrIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGNvbmZpcm1lZCB0cmFuc2FjdGlvblxuICAgIF9ldGhlcmV1bUNhbGwuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHJlc3VsdClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlY2VpcHQpIHtcbiAgICAgICAgaWYgKHJlY2VpcHQgJiYgcmVjZWlwdC5ibG9ja0hhc2gpIHtcbiAgICAgICAgICAgIGlmIChkZWZlci5ldmVudEVtaXR0ZXIubGlzdGVuZXJzKCdjb25maXJtYXRpb24nKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbXVzdCBrZWVwIG9uIHdhdGNoaW5nIGZvciBuZXcgQmxvY2tzLCBpZiBhIGNvbmZpcm1hdGlvbiBsaXN0ZW5lciBpcyBwcmVzZW50XG4gICAgICAgICAgICAgICAgc3RhcnRXYXRjaGluZyhyZWNlaXB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrQ29uZmlybWF0aW9uKHJlY2VpcHQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghcHJvbWlzZVJlc29sdmVkKSB7XG4gICAgICAgICAgICBzdGFydFdhdGNoaW5nKCk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXByb21pc2VSZXNvbHZlZClcbiAgICAgICAgICAgIHN0YXJ0V2F0Y2hpbmcoKTtcbiAgICB9KTtcbn07XG52YXIgZ2V0V2FsbGV0ID0gZnVuY3Rpb24gKGZyb20sIGFjY291bnRzKSB7XG4gICAgdmFyIHdhbGxldCA9IG51bGw7XG4gICAgLy8gaXMgaW5kZXggZ2l2ZW5cbiAgICBpZiAoXy5pc051bWJlcihmcm9tKSkge1xuICAgICAgICB3YWxsZXQgPSBhY2NvdW50cy53YWxsZXRbZnJvbV07XG4gICAgICAgIC8vIGlzIGFjY291bnQgZ2l2ZW5cbiAgICB9XG4gICAgZWxzZSBpZiAoXy5pc09iamVjdChmcm9tKSAmJiBmcm9tLmFkZHJlc3MgJiYgZnJvbS5wcml2YXRlS2V5KSB7XG4gICAgICAgIHdhbGxldCA9IGZyb207XG4gICAgICAgIC8vIHNlYXJjaCBpbiB3YWxsZXQgZm9yIGFkZHJlc3NcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdhbGxldCA9IGFjY291bnRzLndhbGxldFtmcm9tLnRvTG93ZXJDYXNlKCldO1xuICAgIH1cbiAgICByZXR1cm4gd2FsbGV0O1xufTtcbk1ldGhvZC5wcm90b3R5cGUuYnVpbGRDYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtZXRob2QgPSB0aGlzLCBpc1NlbmRUeCA9IChtZXRob2QuY2FsbCA9PT0gJ2V0aF9zZW5kVHJhbnNhY3Rpb24nIHx8IG1ldGhvZC5jYWxsID09PSAnZXRoX3NlbmRSYXdUcmFuc2FjdGlvbicpLCAvLyB8fCBtZXRob2QuY2FsbCA9PT0gJ3BlcnNvbmFsX3NlbmRUcmFuc2FjdGlvbidcbiAgICBpc0NhbGwgPSAobWV0aG9kLmNhbGwgPT09ICdldGhfY2FsbCcpO1xuICAgIC8vIGFjdHVhbCBzZW5kIGZ1bmN0aW9uXG4gICAgdmFyIHNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZWZlciA9IHByb21pRXZlbnQoIWlzU2VuZFR4KSwgcGF5bG9hZCA9IG1ldGhvZC50b1BheWxvYWQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgIC8vIENBTExCQUNLIGZ1bmN0aW9uXG4gICAgICAgIHZhciBzZW5kVHhDYWxsYmFjayA9IGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKG1ldGhvZC5oYW5kbGVSZXZlcnQgJiYgaXNDYWxsICYmIG1ldGhvZC5hYmlDb2Rlcikge1xuICAgICAgICAgICAgICAgIHZhciByZWFzb25EYXRhO1xuICAgICAgICAgICAgICAgIC8vIEdhbmFjaGUgLyBHZXRoIDw9IDEuOS4xMyByZXR1cm4gdGhlIHJlYXNvbiBkYXRhIGFzIGEgc3VjY2Vzc2Z1bCBldGhfY2FsbCByZXNwb25zZVxuICAgICAgICAgICAgICAgIC8vIEdldGggPj0gMS45LjE1IGF0dGFjaGVzIHRoZSByZWFzb24gZGF0YSB0byBhbiBlcnJvciBvYmplY3QuXG4gICAgICAgICAgICAgICAgLy8gR2V0aCAxLjkuMTQgaXMgbWlzc2luZyByZXZlcnQgcmVhc29uIChodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2ViMy5qcy9pc3N1ZXMvMzUyMClcbiAgICAgICAgICAgICAgICBpZiAoIWVyciAmJiBtZXRob2QuaXNSZXZlcnRSZWFzb25TdHJpbmcocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICByZWFzb25EYXRhID0gcmVzdWx0LnN1YnN0cmluZygxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVyciAmJiBlcnIuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZWFzb25EYXRhID0gZXJyLmRhdGEuc3Vic3RyaW5nKDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlYXNvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlYXNvbiA9IG1ldGhvZC5hYmlDb2Rlci5kZWNvZGVQYXJhbWV0ZXIoJ3N0cmluZycsICcweCcgKyByZWFzb25EYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ25hdHVyZSA9ICdFcnJvcihTdHJpbmcpJztcbiAgICAgICAgICAgICAgICAgICAgdXRpbHMuX2ZpcmVFcnJvcihlcnJvcnMuUmV2ZXJ0SW5zdHJ1Y3Rpb25FcnJvcihyZWFzb24sIHNpZ25hdHVyZSksIGRlZmVyLmV2ZW50RW1pdHRlciwgZGVmZXIucmVqZWN0LCBwYXlsb2FkLmNhbGxiYWNrLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IHJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtZXRob2QuZm9ybWF0T3V0cHV0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGVyciA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnIgPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyciA9IGVyci5lcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLl9maXJlRXJyb3IoZXJyLCBkZWZlci5ldmVudEVtaXR0ZXIsIGRlZmVyLnJlamVjdCwgcGF5bG9hZC5jYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXR1cm4gUFJPTUlTRVxuICAgICAgICAgICAgaWYgKCFpc1NlbmRUeCkge1xuICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVyLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIFBST01JRVZFTlRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5lbWl0KCd0cmFuc2FjdGlvbkhhc2gnLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIG1ldGhvZC5fY29uZmlybVRyYW5zYWN0aW9uKGRlZmVyLCByZXN1bHQsIHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBTRU5EUyB0aGUgU0lHTkVEIFNJR05BVFVSRVxuICAgICAgICB2YXIgc2VuZFNpZ25lZFR4ID0gZnVuY3Rpb24gKHNpZ24pIHtcbiAgICAgICAgICAgIHZhciBzaWduZWRQYXlsb2FkID0gXy5leHRlbmQoe30sIHBheWxvYWQsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfc2VuZFJhd1RyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFtzaWduLnJhd1RyYW5zYWN0aW9uXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtZXRob2QucmVxdWVzdE1hbmFnZXIuc2VuZChzaWduZWRQYXlsb2FkLCBzZW5kVHhDYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzZW5kUmVxdWVzdCA9IGZ1bmN0aW9uIChwYXlsb2FkLCBtZXRob2QpIHtcbiAgICAgICAgICAgIGlmIChtZXRob2QgJiYgbWV0aG9kLmFjY291bnRzICYmIG1ldGhvZC5hY2NvdW50cy53YWxsZXQgJiYgbWV0aG9kLmFjY291bnRzLndhbGxldC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2FsbGV0O1xuICAgICAgICAgICAgICAgIC8vIEVUSF9TRU5EVFJBTlNBQ1RJT05cbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5tZXRob2QgPT09ICdldGhfc2VuZFRyYW5zYWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHggPSBwYXlsb2FkLnBhcmFtc1swXTtcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0ID0gZ2V0V2FsbGV0KChfLmlzT2JqZWN0KHR4KSkgPyB0eC5mcm9tIDogbnVsbCwgbWV0aG9kLmFjY291bnRzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2FsbGV0IHdhcyBmb3VuZCwgc2lnbiB0eCwgYW5kIHNlbmQgdXNpbmcgc2VuZFJhd1RyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICh3YWxsZXQgJiYgd2FsbGV0LnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eE9wdGlvbnMgPSBfLm9taXQodHgsICdmcm9tJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmRlZmF1bHRDaGFpbiAmJiAhdHhPcHRpb25zLmNoYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhPcHRpb25zLmNoYWluID0gbWV0aG9kLmRlZmF1bHRDaGFpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QuZGVmYXVsdEhhcmRmb3JrICYmICF0eE9wdGlvbnMuaGFyZGZvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eE9wdGlvbnMuaGFyZGZvcmsgPSBtZXRob2QuZGVmYXVsdEhhcmRmb3JrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZC5kZWZhdWx0Q29tbW9uICYmICF0eE9wdGlvbnMuY29tbW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhPcHRpb25zLmNvbW1vbiA9IG1ldGhvZC5kZWZhdWx0Q29tbW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLmFjY291bnRzLnNpZ25UcmFuc2FjdGlvbih0eE9wdGlvbnMsIHdhbGxldC5wcml2YXRlS2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHNlbmRTaWduZWRUeClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24oZGVmZXIuZXZlbnRFbWl0dGVyLmxpc3RlbmVycykgJiYgZGVmZXIuZXZlbnRFbWl0dGVyLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHVzZXJsYW5kIGVycm9yIHByZXZlbnQgaXQgdG8gYnViYmxlIHVwIHdpdGhpbiB3ZWIzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRVRIX1NJR05cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGF5bG9hZC5tZXRob2QgPT09ICdldGhfc2lnbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBwYXlsb2FkLnBhcmFtc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0ID0gZ2V0V2FsbGV0KHBheWxvYWQucGFyYW1zWzBdLCBtZXRob2QuYWNjb3VudHMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3YWxsZXQgd2FzIGZvdW5kLCBzaWduIHR4LCBhbmQgc2VuZCB1c2luZyBzZW5kUmF3VHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhbGxldCAmJiB3YWxsZXQucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ24gPSBtZXRob2QuYWNjb3VudHMuc2lnbihkYXRhLCB3YWxsZXQucHJpdmF0ZUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQuY2FsbGJhY2sobnVsbCwgc2lnbi5zaWduYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZShzaWduLnNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLnJlcXVlc3RNYW5hZ2VyLnNlbmQocGF5bG9hZCwgc2VuZFR4Q2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICAvLyBTZW5kIHRoZSBhY3R1YWwgdHJhbnNhY3Rpb25cbiAgICAgICAgaWYgKGlzU2VuZFR4ICYmIF8uaXNPYmplY3QocGF5bG9hZC5wYXJhbXNbMF0pICYmIHR5cGVvZiBwYXlsb2FkLnBhcmFtc1swXS5nYXNQcmljZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHZhciBnZXRHYXNQcmljZSA9IChuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnZ2V0R2FzUHJpY2UnLFxuICAgICAgICAgICAgICAgIGNhbGw6ICdldGhfZ2FzUHJpY2UnLFxuICAgICAgICAgICAgICAgIHBhcmFtczogMFxuICAgICAgICAgICAgfSkpLmNyZWF0ZUZ1bmN0aW9uKG1ldGhvZC5yZXF1ZXN0TWFuYWdlcik7XG4gICAgICAgICAgICBnZXRHYXNQcmljZShmdW5jdGlvbiAoZXJyLCBnYXNQcmljZSkge1xuICAgICAgICAgICAgICAgIGlmIChnYXNQcmljZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnBhcmFtc1swXS5nYXNQcmljZSA9IGdhc1ByaWNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTZW5kVHgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIuZW1pdCgnc2VuZGluZycsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VuZFJlcXVlc3QocGF5bG9hZCwgbWV0aG9kKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzU2VuZFR4KSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5lbWl0KCdzZW5kaW5nJywgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZW5kUmVxdWVzdChwYXlsb2FkLCBtZXRob2QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1NlbmRUeCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLmVtaXQoJ3NlbnQnLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZlci5ldmVudEVtaXR0ZXI7XG4gICAgfTtcbiAgICAvLyBuZWNlc3NhcnkgdG8gYXR0YWNoIHRoaW5ncyB0byB0aGUgbWV0aG9kXG4gICAgc2VuZC5tZXRob2QgPSBtZXRob2Q7XG4gICAgLy8gbmVjZXNzYXJ5IGZvciBiYXRjaCByZXF1ZXN0c1xuICAgIHNlbmQucmVxdWVzdCA9IHRoaXMucmVxdWVzdC5iaW5kKHRoaXMpO1xuICAgIHJldHVybiBzZW5kO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgcmV2ZXJ0IHJlYXNvbiBzdHJpbmcgaWYgZXhpc3Rpbmcgb3Igb3RoZXJ3aXNlIGZhbHNlLlxuICpcbiAqIEBtZXRob2QgZ2V0UmV2ZXJ0UmVhc29uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHR4T3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IGJsb2NrTnVtYmVyXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8Qm9vbGVhbnxTdHJpbmc+fVxuICovXG5NZXRob2QucHJvdG90eXBlLmdldFJldmVydFJlYXNvbiA9IGZ1bmN0aW9uICh0eE9wdGlvbnMsIGJsb2NrTnVtYmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIChuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdjYWxsJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfY2FsbCcsXG4gICAgICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgICAgICBhYmlDb2Rlcjogc2VsZi5hYmlDb2RlcixcbiAgICAgICAgICAgIGhhbmRsZVJldmVydDogdHJ1ZVxuICAgICAgICB9KSlcbiAgICAgICAgICAgIC5jcmVhdGVGdW5jdGlvbihzZWxmLnJlcXVlc3RNYW5hZ2VyKSh0eE9wdGlvbnMsIHV0aWxzLm51bWJlclRvSGV4KGJsb2NrTnVtYmVyKSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLnJlYXNvbikge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICByZWFzb246IGVycm9yLnJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBlcnJvci5zaWduYXR1cmVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBoZXggc3RyaW5nIGlzIGEgcmV2ZXJ0IG1lc3NhZ2UgZnJvbSB0aGUgRVZNXG4gKlxuICogQG1ldGhvZCBpc1JldmVydFJlYXNvblN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIC0gSGV4IHN0cmluZyBwcmVmaXhlZCB3aXRoIDB4XG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUuaXNSZXZlcnRSZWFzb25TdHJpbmcgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBfLmlzU3RyaW5nKGRhdGEpICYmICgoZGF0YS5sZW5ndGggLSAyKSAvIDIpICUgMzIgPT09IDQgJiYgZGF0YS5zdWJzdHJpbmcoMCwgMTApID09PSAnMHgwOGMzNzlhMCc7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNyZWF0ZSB0aGUgcHVyZSBKU09OUlBDIHJlcXVlc3Qgd2hpY2ggY2FuIGJlIHVzZWQgaW4gYSBiYXRjaCByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCByZXF1ZXN0XG4gKiBAcmV0dXJuIHtPYmplY3R9IGpzb25ycGMgcmVxdWVzdFxuICovXG5NZXRob2QucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBheWxvYWQgPSB0aGlzLnRvUGF5bG9hZChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICBwYXlsb2FkLmZvcm1hdCA9IHRoaXMuZm9ybWF0T3V0cHV0LmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBNZXRob2Q7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/web3-core-method/lib/index.js\n");

/***/ })

}]);